## RabbitMQ 是什么？

RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。

RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。

PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。

## RabbitMQ 特点?

- **可靠性**: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。
- **灵活的路由** : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。
- **扩展性**: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。
- **高可用性** : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。
- **多种协议**: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。
- **多语言客户端** :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。
- **管理界面** : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。
- **插件机制** : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。

## RabbitMQ 原理是什么？

> zoom

RabbitMQ 是一种常见的开源消息队列软件，它使用 AMQP（高级消息队列协议）作为消息传递协议，并支持多种编程语言和操作系统。

RabbitMQ 基于生产者-消费者模型工作。生产者将消息发布到队列中，而消费者从队列中获取并处理这些消息。队列是 RabbitMQ 中的核心概念，它是一种缓存机制，用于存储消息直到它们被消费者处理为止。

RabbitMQ 中的消息传递过程如下：

1. 生产者将消息发布到队列中。
2. RabbitMQ 将消息存储在队列中，并等待消费者来处理它们。
3. 消费者从队列中获取消息，并对其进行处理。
4. RabbitMQ 标记已处理的消息，并从队列中删除它们。

除了生产者和消费者之外，RabbitMQ 还包括以下组件：

1. Exchange：负责将消息路由到正确的队列中。
2. Binding：连接 Exchange 和队列之间的路由规则。
3. Virtual Host：提供逻辑隔离和安全性，可以在单个 RabbitMQ 实例上创建多个虚拟主机。
4. Connection：生产者和消费者与 RabbitMQ 服务器之间的 TCP 连接。
5. Channel：在单个 TCP 连接上创建多个通信通道，从而允许多个生产者和消费者同时与 RabbitMQ 交互。

总的来说，RabbitMQ 提供了一个可靠的、高度可扩展的消息传递系统，可用于在分布式应用程序中传递和处理数据。

## 消息队列的使用场景

> 蚂蚁

1. 异步任务处理：将耗时的任务放入消息队列中，由后台任务异步处理，避免前台请求阻塞。
2. 流量削峰：当系统面临突发流量时，将请求放入消息队列中，由后台服务异步处理，避免系统崩溃。
3. 分布式系统解耦：将不同系统之间的通信通过消息队列进行解耦，避免系统间的依赖和耦合。
4. 日志处理：将系统日志放入消息队列中，由专门的日志处理服务进行处理，避免日志丢失和系统阻塞。
5. 推送服务：将推送消息放入消息队列中，由后台服务异步进行推送，提高推送的可靠性和效率。
6. 任务调度：将需要定时执行的任务放入消息队列中，由后台服务进行调度，避免漏执行和重复执行。

## AMQP 是什么?

RabbitMQ 就是 AMQP 协议的 `Erlang` 的实现(当然 RabbitMQ 还支持 `STOMP2`、 `MQTT3` 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。

RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。

**AMQP 协议的三层** ：

- **Module Layer**:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。
- **Session Layer**:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。
- **TransportLayer**:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。

**AMQP 模型的三大组件** ：

- **交换器 (Exchange)** ：消息代理服务器中用于把消息路由到队列的组件。
- **队列 (Queue)** ：用来存储消息的数据结构，位于硬盘或内存中。
- **绑定 (Binding)** ：一套规则，告知交换器消息应该将消息投递给哪个队列。

## RabbitMQ的核心组件

- **Producer(生产者)** :生产消息的一方（邮件投递者）

- **Consumer(消费者)** :消费消息的一方（邮件收件人）

- **Broker** ： 可以看做 RabbitMQ 的服务节点。一般情况下一个 Broker 可以看做一个 RabbitMQ 服务器。

- **Queue** :RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。

- **Exchange** : 生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。

  RabbitMQ 常用的 Exchange Type 有 **fanout**、**direct**、**topic**、**headers** 这四种

  ##### ① fanout

  fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。

  ##### ② direct

  direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。

  ![direct 类型交换器](https://oss.javaguide.cn/github/javaguide/rabbitmq/37008021.jpg)

  以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为"Info”或者"debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。

  direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。

  ##### ③ topic

  前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：

  - RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;
  - BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；
  - BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。

  ![topic 类型交换器](https://oss.javaguide.cn/github/javaguide/rabbitmq/73843.jpg)

  以上图为例：

  - 路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queue1 和 Queue2;
  - 路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；
  - 路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；
  - 路由键为 “java.rabbitmq.demo” 的消息只会路由到 Queue1 中；
  - 路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。

  ##### ④ headers(不推荐)

  headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。

## 什么是死信队列？如何导致的？

DLX，全称为 `Dead-Letter-Exchange`，死信交换器，死信邮箱。当消息在一个队列中变成死信 (`dead message`) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。

**导致的死信的几种原因**：

- 消息被拒（`Basic.Reject /Basic.Nack`) 且 `requeue = false`。
- 消息 TTL 过期。
- 队列满了，无法再添加。

## 什么是延迟队列？RabbitMQ 怎么实现延迟队列？

延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。

RabbitMQ本身是没有延迟队列的，要实现延迟消息，一般有两种方式：

1. 通过RabbitMQ本身队列的特性来实现，需要使用RabbitMQ的死信交换机（Exchange）和消息的存活时间TTL（Time To Live）。
2. 在RabbitMQ 3.5.7及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖Erlang/OPT 18.0及以上。

也就是说，AMQP 协议以及RabbitMQ本身没有直接支持延迟队列的功能，但是可以通过TTL和DLX模拟出延迟队列的功能。

## 什么是优先级队列？

RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。

可以通过`x-max-priority`参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。

## RabbitMQ 有哪些工作模式？

1. 简单模式（Simple Mode）：也称为点对点模式（Point-to-Point），消息发送方（Producer）将消息发送到一个队列（Queue）中，消息接收方（Consumer）从队列中取出消息并处理。在这种模式下，每个消息只能被一个消费者接收，一旦被接收后，消息将从队列中删除。
2. 发布订阅模式（Publish/Subscribe Mode）：消息发送方（Producer）将消息发送到一个交换机（Exchange）中，多个消息接收方（Consumer）将队列（Queue）绑定到这个交换机上并接收消息。在这种模式下，一个消息可以被多个消费者接收，每个消费者都会收到一份消息副本。
3. 路由模式（Routing Mode）：消息发送方（Producer）将消息发送到一个交换机（Exchange）中，并指定一个路由键（Routing Key），消息接收方（Consumer）将队列（Queue）绑定到这个交换机上，并指定一个匹配规则（Binding Key）。交换机根据路由键和绑定键的匹配关系将消息发送到相应的队列中。
4. 主题模式（Topic Mode）：主题模式是路由模式的一种扩展，它支持更灵活的匹配规则。消息发送方（Producer）将消息发送到一个交换机（Exchange）中，并指定一个主题（Topic），消息接收方（Consumer）将队列（Queue）绑定到这个交换机上，并指定一个匹配规则（Binding Key）。交换机根据主题和绑定键的匹配关系将消息发送到相应的队列中。

## RabbitMQ 消息怎么传输？

由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 RabbitMQ 使用信道的方式来传输数据。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。

## RabbitMQ发生消息丢失怎么处理

> 蚂蚁，美团

#### 生产者弄丢了数据

生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。

此时可以选择用 RabbitMQ 提供的事务功能，就是生产者**发送数据之前**开启 RabbitMQ 事务`channel.txSelect`，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务`channel.txRollback`，然后重试发送消息；如果收到了消息，那么可以提交事务`channel.txCommit`。

```java
// 开启事务
channel.txSelect
try {
    // 这里发送消息
} catch (Exception e) {
    channel.txRollback

    // 这里再次重发这条消息
}

// 提交事务
channel.txCommit
```

但是问题是，RabbitMQ 事务机制（同步）一搞，基本上**吞吐量会下来，因为太耗性能**。

所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 `confirm` 模式，在生产者那里设置开启 `confirm` 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 `ack` 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 `nack` 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。

事务机制和 `cnofirm` 机制最大的不同在于，**事务机制是同步的**，你提交一个事务之后会**阻塞**在那儿，但是 `confirm` 机制是**异步**的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。

所以一般在生产者这块**避免数据丢失**，都是用 `confirm` 机制的。

#### RabbitMQ 弄丢了数据

就是 RabbitMQ 自己弄丢了数据，这个你必须**开启 RabbitMQ 的持久化**，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，**恢复之后会自动读取之前存储的数据**，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，**可能导致少量数据丢失**，但是这个概率较小。

设置持久化有**两个步骤**：

- 创建 queue 的时候将其设置为持久化

  这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。

- 第二个是发送消息的时候将消息的 `deliveryMode` 设置为 2

  就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。

必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。

注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。

所以，持久化可以跟生产者那边的 `confirm` 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 `ack` 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 `ack`，你也是可以自己重发的。

#### 消费端弄丢了数据

RabbitMQ 如果丢失了数据，主要是因为你消费的时候，**刚消费到，还没处理，结果进程挂了**，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。

这个时候得用 RabbitMQ 提供的 `ack` 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 `ack`，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 `ack` 一把。这样的话，如果你还没处理完，不就没有 `ack` 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消息分配给别的 consumer 去处理，消息是不会丢的。

![img](https:////upload-images.jianshu.io/upload_images/10089464-2119c110e12e547e.png?imageMogr2/auto-orient/strip|imageView2/2/w/594/format/webp)

## 如何保证 RabbitMQ 消息的顺序性？

> 美团

在 RabbitMQ 中保证消息的顺序性是比较复杂的问题，需要根据具体的业务场景和需求选择合适的方案。下面列出几种可行的方案：

1. 通过单个队列实现：将所有需要按照顺序处理的消息发送到同一个队列中，并且只分配一个消费者消费队列中的消息。这种方式可以保证消息的顺序性，但是会影响并发处理能力。
2. 通过多个队列实现：将需要按照顺序处理的消息根据一定的规则（例如消息 ID 或者时间戳）发送到不同的队列中。每个队列只分配一个消费者消费，确保每个队列中的消息都按照相同的顺序进行处理。这种方式可以提高并发处理能力，但是需要在消费者端进行消息的重新组合。
3. 通过消息排序实现：将消息发送到 RabbitMQ 后，消费者先将消息存储在缓存中，等到所有消息都到达后，再进行排序处理。这种方式可以保证消息的顺序性，但是需要缓存所有的消息，可能会占用大量的内存资源。
4. 通过插件实现：RabbitMQ 提供了一个插件 rabbitmq_delayed_message_exchange，可以通过该插件实现延迟队列和延迟消息。在发送消息时，将消息发送到延迟队列中，并设置延迟时间，在延迟时间到达后，将消息发送到指定的队列中。这种方式可以保证消息的顺序性和延迟性。

综上所述，根据不同的业务场景和需求，可以选择不同的方案来保证 RabbitMQ 消息的顺序性。

## 如何保证 RabbitMQ 高可用的？

RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。

**单机模式**

Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式。

**普通集群模式**

意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。

你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。

**镜像集群模式**

这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。

这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。

## 如何解决消息队列的延时以及过期失效问题？

RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。

## RabbitMQ的死信队列

> 美团

在 RabbitMQ 中，当一条消息被发送到队列中时，如果它不能被消费者正确处理，那么这条消息可能会被重新入队（即重新投递）。如果这种情况发生了一定次数（可以在队列的配置中指定），那么该消息将被移到死信队列中，等待进一步处理。

死信队列是一个专门用来处理无法被消费者处理的消息的队列。它通常被用于记录无法被处理的消息的相关信息，以便后续的处理或者调查。

使用死信队列可以帮助 RabbitMQ 更好地处理无法被正确消费的消息，提高消息的可靠性和稳定性。

## MQ用来做什么的？消息队列的使用场景？

> 美团

消息队列（MQ）是一种应用程序间通信的解决方案，它将消息存储在一个队列中，等待接收者从队列中读取并处理消息。消息队列可以使不同应用程序之间的通信更加简单、高效、可靠。

消息队列的使用场景很多，以下是其中几个典型的场景：

1. 异步处理：当有些任务不需要立即处理完成，而是需要在之后的某个时间点处理，我们可以将这些任务放到消息队列中，等待后续的处理。
2. 应用解耦：当一个应用需要与多个应用进行通信时，如果直接进行点对点的通信，那么这些应用之间会产生严重的耦合性。而通过引入消息队列，不同应用之间可以通过消息队列进行通信，从而降低了应用之间的耦合度。
3. 流量削锋：当一个应用面对突发流量时，如果直接将这些请求转发到后端服务中处理，可能会导致后端服务的不可用。而通过将请求放到消息队列中，可以使流量得到平滑处理，从而保证后端服务的可用性。
4. 日志处理：当应用需要将日志写入文件或数据库时，可以将日志消息放到消息队列中，由专门的消费者进行消费，从而降低对应用性能的影响。

总之，消息队列的使用场景非常广泛，它可以使应用程序之间的通信更加简单、高效、可靠，可以提高系统的可伸缩性和可靠性，是构建分布式系统的重要组件之一。

## rabbitmq如何保证消息一定被消费一次

> 美团

在RabbitMQ中，确保消息被消费一次有多种方法，其中包括：

1. 消费者手动应答模式（手动确认ack）：在消费消息时，将确认模式设置为手动，等到消息处理完毕后再进行确认，如果处理失败则可以不确认，此时消息会重新放回队列等待处理，确保消息不会被丢失或重复消费。
2. 消费端幂等性设计：在消费端实现幂等性处理，即保证同一条消息重复消费时，结果不会受到影响。可以通过记录已经消费的消息ID或者使用一些特殊的处理方式来实现。
3. 去重表：通过创建一个去重表，记录每一条消息的消费状态，消费者在消费消息之前先查询去重表，如果已经存在相应的记录，则表示该消息已经被消费，不需要再次处理。
4. TTL机制：可以给消息设置一个TTL（Time To Live）过期时间，在消费者消费的时候，只处理还未过期的消息。这样可以确保消息不会被一直堆积在队列中，导致消费者一直无法消费。

这些方法都可以用来保证消息只被消费一次，但是具体的实现方式还需要根据业务场景和需求来选择。

## 交换机和队列的联系

> 字节

一般情况下，为了让生产者和消费者充分解耦，理想情况下，生产者仅仅直到关于交换机达的信息，消费者仅仅直到队列的信息，绑定关系表明交换机和队列的关系。

当然也可以生产者/消费者/CLI创建一切

路由键：消息绑定到交换机上的规则，消息根据规则由交换机将消息投递到相对应的队列。如果路由消息不匹配任何绑定，消息将进入黑洞。

direct交换器（header类似，性能差）：如果路由键匹配，消息就会被投递到对应的队列。服务器必须实现direct类型交换器，包含一个空白字符串命名的默认交换器。当声明一个队列时，它会自动绑定到默认交换器，并以队列名作为路由键。

![在这里插入图片描述](https://img-blog.csdnimg.cn/361db5ed4d9a402da02050fcbbd04440.png)

fanout交换器：当发送一套消息到fanout交换器时，它会把消息投递到所有附加在此交换器上的队列。

![在这里插入图片描述](https://img-blog.csdnimg.cn/31ecd399a3af44be847ab415cb5053b2.png)

topic交换器：这类交换器根据topic可以使得不同源头的消息到达同一个队列。

![在这里插入图片描述](https://img-blog.csdnimg.cn/f09dd3ce53c34dcb863cfc4ea6f9b5af.png)

## mq 消息挤压如何处理

> 美团

消息挤压是指当MQ服务器负载过高时，消息的生产者一直在不停地生产消息，而消费者无法及时消费，导致MQ服务器存储的消息数量超出了其承载能力，进而导致服务宕机或消息堆积等问题。

处理MQ消息挤压的方法：

1. 设置合理的消费端并发数，避免过高的并发数导致消息积压。
2. 调整MQ服务器的配置参数，如增加硬件资源、调整队列大小等。
3. 对于高并发场景，可以采用分布式消息队列来进行水平扩展，将消息分散到多个节点上处理，以提高整个MQ系统的处理能力。
4. 针对特定的业务场景，可以采用延时队列等方式，避免短时间内大量的消息一起被生产和消费。
5. 设置消息的过期时间，避免消息无限制地积压在MQ服务器上。
6. 监控MQ服务器的负载情况，及时发现并处理积压消息的情况。
