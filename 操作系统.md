## 冯诺依曼体系结构

> 美团

冯·诺伊曼体系结构是一种计算机设计原则，它在计算机科学中有着广泛的应用。该体系结构以冯·诺伊曼命名，他是一位著名的数学家和计算机科学家。

冯·诺伊曼体系结构的主要特点是将程序和数据存储在同一存储器中，计算机执行指令时，将指令从存储器中读取到处理器中执行。这种结构的计算机被称为“存储程序计算机”。

冯·诺伊曼体系结构包括四个主要部分：中央处理器（CPU）、存储器、输入/输出设备和总线。CPU执行指令，存储器存储程序和数据，输入/输出设备负责输入和输出数据，总线则连接这些部件。

冯·诺伊曼体系结构的优点是易于设计和实现，同时也具有高效的执行速度。它为计算机科学的发展奠定了基础，是现代计算机设计的基础。

## 用户态和内核态？

> 阿里，美团

用户态和内核态是指计算机操作系统中的两种不同的运行模式。

在用户态下，应用程序只能访问自己的内存空间和 CPU 的部分功能，而不能直接访问计算机系统的硬件资源或者操作系统的内核代码。

在内核态下，操作系统具有更高的权限，可以访问系统的硬件资源，包括 CPU、内存、磁盘等，并且可以执行敏感的操作，例如修改系统内核数据结构、调度进程等。

操作系统之所以分为用户态和内核态，是为了保护系统的稳定性和安全性。用户态下的应用程序不能直接访问操作系统的内核代码和敏感资源，只能通过操作系统提供的接口来访问。操作系统在内核态下提供了一组系统调用接口，允许应用程序请求操作系统提供的服务，例如读写文件、创建进程等。这种设计可以避免应用程序随意修改操作系统的内部数据结构，导致系统崩溃或安全漏洞。

因此，用户态和内核态的分离是操作系统的一个核心设计原则，也是保障系统稳定性和安全性的重要手段。

## 进程有哪几种状态?

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

## 进程、进程通信、上下文切换

> 蚂蚁

**进程：**

进程是指正在运行的程序实例，它是系统进行资源分配和调度的基本单位。进程具有独立的地址空间、文件描述符、内存空间和堆栈，它们之间相互独立，互不干扰。

**进程通信：**

进程通信是指不同进程之间交换信息的机制。在现代操作系统中，进程通信是必须的，因为不同进程之间需要相互协作来完成各种任务。常见的进程通信方式有管道、信号、共享内存、消息队列和Socket等。

**上下文切换：**

上下文切换是指操作系统在执行多任务时，从当前进程的上下文中保存状态，然后切换到另一个进程的上下文中执行的过程。上下文切换是系统调度和运行进程的必要操作之一。当一个进程被抢占或者自愿地放弃CPU的使用权时，操作系统会执行上下文切换，保存当前进程的状态信息（包括进程寄存器、PC等）到进程控制块中，然后将处理器分配给下一个等待运行的进程，并且更新相应的进程控制块，从而实现进程切换。

上下文切换是需要付出代价的，因为在切换过程中需要保存和恢复多个进程的上下文信息，这些操作会消耗系统资源，导致系统性能下降。因此，优化上下文切换是系统调度的一个重要方面。

## 进程的锁机制

> 蚂蚁

进程锁是一种用于同步访问共享资源的机制，用于避免多个进程同时访问共享资源时出现的数据竞争和冲突问题。在进程锁机制中，通常会使用互斥锁、读写锁和条件变量等机制来保护共享资源的访问。以下是进程锁机制中常见的锁类型：

1. 互斥锁

互斥锁也称为独占锁，它是一种基本的进程同步机制，用于保护共享资源的访问。在同一时刻只允许一个进程对共享资源进行访问，其他进程需要等待当前进程释放锁后才能访问共享资源。

2. 读写锁

读写锁是一种高效的进程同步机制，它允许多个进程同时访问共享资源，但是对于写操作，只允许一个进程进行，其他进程需要等待写操作完成后才能访问共享资源。

3. 条件变量

条件变量是一种进程同步机制，它可以让进程在特定的条件下等待或唤醒。在进程访问共享资源时，如果发现资源已被占用，则可以使用条件变量将进程挂起等待资源释放，当资源释放后，条件变量会通知等待的进程继续执行。

除了上述锁类型外，还有一些其他的进程锁机制，如信号量、屏障等。在使用进程锁机制时，需要根据实际情况选择适当的锁类型，以保证共享资源的安全访问。同时，还需要避免死锁等问题的发生，提高系统的可靠性和性能。

## 进程通信

> 字节，腾讯，华为，快手

1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
2. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
4. **消息队列(Message Queuing)** ：**消息队列就是保存在内核中的消息链表**，包括Posix消息队列和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

## Fork函数

> 字节

`fork`函数用于创建一个与当前进程一样的子进程，所创建的子进程将复制父进程的代码段、数据段、BSS段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。

`fork`系统调用会通过复制一个现有进程来创建一个全新的进程，新进程被存放在一个叫做任务队列的双向循环链表中，链表中的每一项都是类型为`task_struct`的进程控制块`PCB`的结构。

![img](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/os-ee3d0c6b-9d93-4f9d-95f3-86e7d195a8f8.png)

每个进程都由独特换不相同的进程标识符（PID），通过`getpid()`函数可获取当前进程的进程标识符，通过`getppid()`函数可获得父进程的进程标识符。

一个现有的进程可通过调用`fork`函数创建一个新进程，由`fork`创建的新进程称为子进程`child process`，`fork`函数被调用一次但返回两次，两次返回的唯一区别是子进程中返回0而父进程中返回子进程ID。

**为什么`fork`会返回两次呢？**

因为复制时会复制父进程的堆栈段，所以两个进程都停留在`fork`函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。

- 在父进程中将返回新建子进程的进程ID
- 在子进程中将返回0
- 若出现错误则返回一个负数

因此可以通过`fork`的返回值来判断当前进程是子进程还是父进程。

**fork执行执行流程**

当进程调用`fork`后控制转入内核，内核将会做4件事儿：

1. 分配新的内存块和内核数据结构给子进程
2. 将父进程部分数据结构内容（数据空间、堆栈等）拷贝到子进程
3. 添加子进程到系统进程列表中
4. `fork`返回开始调度器调度

**为什么`pid`在父子进程中不同呢？**

其实就相当于链表，进程形成了链表，父进程的`pid`指向子进程的进程ID，因此子进程没有子进程，所以PID为0，这里的`pid`相当于链表中的指针。

## 线程和进程的区别

> 小米，字节，腾讯，华为，美团，蚂蚁，阿里，快手

- 调度：进程是资源管理的基本单位，线程是程序执行的基本单位。
- 切换：线程上下文切换比进程上下文切换要快得多。
- 拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。
- 系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。

## 一个进程崩溃了会导致线程崩溃吗？

> 美团

在一个进程中，多个线程共享同一块内存空间，如果一个线程访问了一个非法地址，那么会导致该线程崩溃，但不一定会导致整个进程崩溃。

如果一个进程崩溃了，可能会导致所有的线程都奔溃，但不是绝对的。进程崩溃的原因有很多，例如内存泄漏、死锁、非法操作等，不同的原因可能会导致不同的后果。如果进程崩溃的原因是内存泄漏，那么可能会导致整个系统的内存资源耗尽，从而使得其他进程和线程也无法正常运行；如果是死锁，那么可能会导致其他线程一直处于阻塞状态，无法进行任何操作；如果是非法操作，那么可能会导致进程崩溃的同时，其他线程仍然在正常运行。

因此，进程崩溃不一定会导致线程崩溃，但是进程崩溃可能会对其他线程产生不同的影响，具体取决于进程崩溃的原因和程序的实现方式。

## 线程是依赖进程的资源的，具体是哪些资源呢？

> 阿里

线程是依赖于进程的资源的，因为线程只是进程内的一个执行单元，它们共享进程的资源。具体来说，线程依赖于以下进程资源：

1. 内存空间：线程共享进程的地址空间，包括代码段、数据段、堆和栈等。
2. 文件描述符：每个线程都可以访问进程打开的文件，因为它们共享文件描述符表。
3. 运行时系统信息：线程共享进程的进程控制块（Process Control Block, PCB）、信号处理器和进程优先级等运行时系统信息。
4. 共享库代码和数据：线程可以共享动态链接库（Dynamic Linking Library, DLL）的代码和数据，这样可以节省内存空间和加快程序启动速度。

需要注意的是，每个线程都有自己的线程控制块（Thread Control Block, TCB），它包含了线程的状态、寄存器值、堆栈指针、优先级等信息。线程之间的切换需要保存和恢复TCB中的信息，这些操作由操作系统的调度器来完成。

## 进程、线程、协程的区别

> 滴滴，阿里，快手

**进程**

进程是操作系统中进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间和系统资源，可以运行在自己的进程上下文中。不同进程之间的通信需要通过特定的机制，比如管道、消息队列等。

**线程**

线程是进程中的一个实体，一个进程可以包含多个线程，它们共享进程的资源（内存、文件句柄等）。线程是操作系统能够进行调度的最小单位，也就是说，调度器可以在不同的线程之间切换。线程之间的通信相对于进程来说更加容易。

**协程**

协程是一种用户态的轻量级线程，也就是说，它们不需要操作系统的支持。协程之间的切换是在用户态完成的，因此非常快速。协程的主要特点是可以在同一个线程中实现多个协程的调度和切换，从而提高了程序的并发性能。

**总结**

进程、线程、协程都是用来实现多任务的方式，但是它们之间有一些区别。进程是最基本的单位，线程是进程中的实体，协程是一种轻量级的线程。在实际应用中，需要根据具体的场景选择合适的多任务方式。

## 进程同步

> 阿里云

进程同步是指在多个进程或线程之间，为了协调它们的执行顺序或访问共享资源，采取的一些机制或技术，以保证它们的执行结果是正确的。

常见的进程同步机制包括：

1. 互斥锁：一次只允许一个进程或线程访问共享资源，其他进程或线程需要等待。
2. 信号量：用来控制多个进程或线程对共享资源的访问数量，可用于进程通信。
3. 条件变量：通过等待和唤醒的方式来实现进程之间的同步和通信。
4. 屏障：用来协调多个进程或线程的执行顺序，让它们在同一时间点执行某个操作。

进程同步的目的是避免并发执行时的数据竞争、死锁、饥饿等问题，保证程序的正确性和稳定性。

## 线程间的同步的方式

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semaphore)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
3. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

## 进程的调度算法

> 快手，阿里云

- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法** ：将进程分成多个队列，按照优先级和进程需要的时间划分到不同的队列中，同一队列中的进程采用时间片轮转算法，不同队列之间可以根据需要调整优先级。
- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

## 哲学家就餐问题

> 阿里云

哲学家就餐问题是一个经典的进程同步问题，它描述的是五个哲学家共用一张圆桌进行进餐的场景，每个哲学家的周围都放有一盘面条和一只叉子。哲学家从思考状态进入饥饿状态，只有同时拿到左右两只叉子才能进餐，进餐完毕后放下叉子继续思考。问题的关键在于如何防止死锁和饥饿问题的发生。

常见的解法包括：

1.资源分级法：给每个叉子分配一个编号，要求必须先拿编号小的叉子，再拿编号大的叉子，从而避免死锁问题。

2.限制进餐人数法：限制同时只有 n-1 个哲学家进餐，从而保证一定有一些哲学家能够拿到叉子进餐，避免饥饿问题。

3.避免等待法：通过给每个哲学家设置一个状态，表示是否等待，如果有一个哲学家不能获取到叉子，就不等待，释放已经拿到的叉子，从而避免死锁问题。

## 死锁的四个必要条件

> 上海银行苏州研发中心，美团，阿里，快手，蚂蚁

**互斥**：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。

**占有并等待**：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。

**非抢占**：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。

**循环等待**：有一组等待进程 `{P0, P1,..., Pn}`， `P0` 等待的资源被 `P1` 占有，`P1` 等待的资源被 `P2` 占有，......，`Pn-1` 等待的资源被 `Pn` 占有，`Pn` 等待的资源被 `P0` 占有。

## 怎么避免死锁或解决死锁

> 华为，快手，阿里，蚂蚁

为了避免死锁，可以采用以下方法：

1. 破坏互斥条件：将一些资源设计为可共享的，不仅仅是独占的。
2. 破坏占有并等待条件：采用资源预先分配策略，进程在开始执行之前就申请到了所有需要的资源。
3. 破坏非抢占条件：引入资源抢占机制，当某个进程占用的资源被其他进程请求时，可以抢占该进程的资源。
4. 破坏循环等待条件：对资源进行编号，规定每个进程按编号递增的顺序请求资源，释放资源则按编号递减的顺序释放。

## 操作系统的内存管理机制？详细说一下并说明其优缺点？

> 阿里

操作系统的内存管理机制是指操作系统如何管理计算机的内存资源，以便合理地分配和利用内存空间，提高系统的性能和稳定性。

操作系统的内存管理机制包括以下几个方面：

1. 地址映射（Address Mapping）：内存管理单元通过地址映射将逻辑地址（Logical Address）转换为物理地址（Physical Address）。
2. 内存分配（Memory Allocation）：内存管理单元将物理内存划分为若干个分区（Partition），每个分区可以分配给一个进程使用，分配方式包括动态分配（Dynamic Allocation）和静态分配（Static Allocation）。
3. 内存保护（Memory Protection）：操作系统通过内存保护机制，保护系统内存不被非法访问或修改。
4. 内存回收（Memory Reclamation）：当进程释放内存或进程终止时，操作系统需要回收分配给该进程的内存，以便供其他进程使用。
5. 虚拟内存（Virtual Memory）：操作系统为每个进程分配一定的虚拟内存空间，以便让进程能够访问大于实际物理内存的内存空间，增加了系统的内存利用率。

内存管理机制的优点：

1. 提高系统性能：内存管理机制能够让操作系统更好地利用内存资源，提高系统的性能。
2. 提高系统稳定性：内存管理机制能够通过内存保护和回收机制，避免因为进程访问不当或内存泄漏导致系统崩溃的情况。
3. 提高系统安全性：内存管理机制可以保护系统内存不被非法访问或修改，从而提高系统安全性。

内存管理机制的缺点：

1. 系统开销较大：内存管理机制需要消耗一定的系统资源，包括内存空间、CPU时间和I/O资源等。
2. 容易出现内存碎片：内存管理机制容易导致内存碎片的产生，导致内存空间的利用率下降。
3. 会降低系统的可靠性：内存管理机制的实现可能会存在漏洞，从而导致系统的可靠性下降。

综上所述，操作系统的内存管理机制在提高系统性能、稳定性和安全性方面具有重要的作用，但也存在一些缺点需要考虑。因此，在实际应用中，需要根据具体情况选择合适的内存管理策略。

## 内存页面置换算法

> 字节，拼多多

地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。

> **缺页中断** 就是要访问的**页**不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。

当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。

- **OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
- **LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** : 该置换算法选择在之前时期使用最少的页面作为淘汰页。

------

## 虚拟内存和物理内存

> 阿里

虚拟内存和物理内存是计算机系统中两种不同的存储方式。

物理内存是计算机实际拥有的内存，通常由RAM（随机访问存储器）组成，它是计算机用于存储程序和数据的主要存储设备。物理内存的大小通常是有限的，这意味着计算机系统可能无法同时容纳所有正在运行的程序和数据。

虚拟内存则是一种通过硬盘空间扩展物理内存容量的技术。当计算机系统需要更多的内存时，它将物理内存中当前不需要的数据移到硬盘上的虚拟内存空间中。这样就可以将物理内存留给正在运行的程序和数据，而不会因为内存不足而导致系统崩溃。

虚拟内存的工作原理是将物理内存划分成大小相等的块，称为页面。同样地，硬盘上的虚拟内存也被划分为大小相等的页面。当物理内存不足时，系统将最近不使用的页面移动到虚拟内存中，从而为正在运行的程序腾出物理内存空间。当程序需要之前移动到虚拟内存中的数据时，系统会将其从虚拟内存中读取回来。

虚拟内存的优点是它可以大大增加系统的可用内存空间。缺点是虚拟内存的访问速度通常比物理内存慢，因为它需要从硬盘上读取数据。此外，由于虚拟内存管理是由操作系统负责的，所以对系统性能的影响也可能是难以预测的。

## 中断和轮询

中断和轮询是两种不同的数据传输方式。中断是一种主动的数据传输方式，当设备需要传输数据时，它会发出一个中断信号，以便让CPU处理它。轮询是一种被动的数据传输方式，它需要CPU定期查询设备，以检查是否有数据需要传输。

## 操作系统 I/O的模型有哪几种？

> 快手

操作系统 I/O 的模型主要有以下几种：

1. 阻塞 I/O 模型（Blocking I/O Model）：应用程序调用 I/O 操作后，线程被阻塞，直到 I/O 操作完成才会继续执行。
2. 非阻塞 I/O 模型（Non-blocking I/O Model）：应用程序调用 I/O 操作后，线程不会被阻塞，而是立即返回一个错误码或状态值。线程可以继续执行其他任务，定时或轮询检查 I/O 操作是否完成，直到 I/O 操作完成后再处理数据。
3. I/O 复用模型（I/O Multiplexing Model）：应用程序调用 select、poll、epoll 等系统调用，将需要进行 I/O 操作的文件描述符注册到内核中，然后线程被阻塞，等待某个文件描述符就绪，当文件描述符就绪后，线程被唤醒，进行 I/O 操作。
4. 信号驱动 I/O 模型（Signal-driven I/O Model）：应用程序调用 fcntl 系统调用设置一个文件描述符为信号驱动模式，当文件描述符就绪时，内核向进程发送一个 SIGIO 信号，进程接收到信号后，处理数据。
5. 异步 I/O 模型（Asynchronous I/O Model）：应用程序调用 aio_read、aio_write 等系统调用发起 I/O 操作，然后线程不会被阻塞，可以继续执行其他任务。当 I/O 操作完成后，内核会通知应用程序，应用程序处理数据。这种模型通常需要操作系统支持异步 I/O。
