# MySQL

## MySQL数据类型

> 唯品会

MySQL支持多种数据类型，可以根据不同的数据类型选择合适的存储方式和索引类型，以提高数据库的性能和可靠性。MySQL数据类型主要可以分为以下几类：

1. 数值类型：包括整型（int、bigint等）、小数类型（float、double等）和位类型（bit）。数值类型可以进行基本的数值计算和比较，适用于需要存储数值类型的数据。
2. 日期和时间类型：包括日期类型（date）、时间类型（time）、日期时间类型（datetime）和时间戳类型（timestamp）。日期和时间类型可以用于存储日期、时间和时间间隔等信息，常用于日历、预定和记录系统日志等应用。
3. 字符串类型：包括固定长度字符串类型（char）和变长字符串类型（varchar）、文本类型（text）、二进制类型（blob）等。字符串类型适用于存储文本、图像和多媒体数据等信息。
4. 布尔类型：只有两个取值（0或1），适用于存储逻辑类型的数据。
5. 枚举类型：用于存储一组可选值，可以从预定义的值列表中选择。
6. 集合类型：用于存储一组可选值的组合，可以从预定义的值列表中选择多个值。

在实际应用中，需要根据具体的业务需求和数据特征选择合适的数据类型，并注意数据类型的存储空间和精度，避免数据冗余和溢出等问题。

## MySQL 的逻辑架构了解吗？

> 比亚迪

MySQL 的逻辑架构可以分为三个主要组件：连接管理器，查询分析器和存储引擎。

1. 连接管理器：连接管理器负责管理客户端与服务器之间的连接。当客户端连接到服务器时，连接管理器负责验证身份，分配资源和建立通信通道。在一个 MySQL 服务器上可以同时支持多个客户端连接，因此连接管理器必须能够有效地处理这些连接。
2. 查询分析器：查询分析器是 MySQL 的核心组件，负责解析和执行 SQL 查询语句。当客户端发送一个 SQL 查询请求时，查询分析器首先检查语法，然后将其转换成一系列的操作，最终调用存储引擎来执行查询。查询分析器还可以优化查询以提高性能，并在必要时进行索引扫描或表扫描。
3. 存储引擎：存储引擎负责将数据存储在物理存储介质上，如磁盘或内存。MySQL 支持多种存储引擎，包括 InnoDB、MyISAM、MEMORY、CSV 等。每个存储引擎都有其独特的优缺点，可以根据具体情况进行选择。

总体来说，MySQL 的逻辑架构是一个基于客户端-服务器模型的架构，其中客户端通过连接管理器连接到服务器，查询分析器处理 SQL 查询请求并调用存储引擎来执行查询。不同的存储引擎可以提供不同的数据存储和查询功能，使 MySQL 能够满足不同应用的需求。

## binlog，redolog，undolog

> 字节

二进制日志（binlog）记录了所有对数据的更新，包括数据库表结构的更改，这些更新可以在主从复制、数据恢复和数据备份中使用。

重做日志（redolog）记录了数据库事务操作所产生的物理变化，用于确保事务的原子性和一致性，并且保证在系统崩溃的情况下数据的完整性。在每个事务提交之前，重做日志都必须被写入磁盘。

回滚日志（undolog）记录了事务的逻辑变化，主要是记录在事务回滚时如何撤销已经提交的事务。回滚日志只在事务回滚时需要用到。

## mysql页结构和行结构

> 美团

MySQL中的存储结构是以页（Page）为单位进行组织的，每个页的大小默认为16KB，其中包含了多个行（Row）。

页结构包含了页头和页体两部分。页头主要用于存储一些元数据信息，例如页的编号、页类型、页状态等；页体则是存储行数据的地方。页体又被划分为多个数据块（Data Block），每个数据块包含了一行或多行的数据，以及一些数据块的元数据信息，例如数据块的起始位置、结束位置、已使用的空间大小等。

行结构是指MySQL中数据表中的行（也称为记录），每行数据都由多个列（Column）组成，每个列包含了数据类型、长度、值等信息。每行数据还包含了一些元数据信息，例如行的状态、行的创建时间、最后修改时间等。在MySQL中，行是以字节流的形式存储在页中的数据块中的。

MySQL在实现行结构时采用了变长字段和定长字段的结合方式，其中定长字段存储的是长度固定的数据类型，例如整数、日期等；而变长字段则存储长度可变的数据类型，例如字符串、文本等。为了提高查询性能和存储效率，MySQL采用了数据压缩和编码方式等技术对行数据进行压缩和编码，以减少数据的存储空间和I/O操作的次数。

## mysql的级联有用过吗？存储引擎是如何实现级联的？

> 美团

MySQL中的级联（Cascade）指的是在一个表中的某些操作会自动触发另一个表中的相关操作，例如删除一个记录时，可以自动删除相关联的记录。MySQL的存储引擎实现级联的方式与存储引擎相关。

在InnoDB存储引擎中，MySQL支持使用外键来实现级联。外键是指一张表中的列引用另一张表的列。如果在InnoDB中定义了外键，那么当进行一些操作时，会自动触发与之相关的操作。下面是InnoDB中支持的级联操作：

1. CASCADE

当在主表中进行UPDATE或DELETE操作时，自动在从表中进行相同的操作。

2. RESTRICT

当在主表中进行UPDATE或DELETE操作时，如果从表中存在相应的行，则不允许进行操作，抛出错误。

3. NO ACTION

与RESTRICT相同，不执行级联操作，抛出错误。

4. SET NULL

当在主表中进行UPDATE操作时，如果从表中存在相应的行，则将从表中相关的列设为NULL。

5. SET DEFAULT

与SET NULL相同，但将从表中相关的列设为默认值。

例如，以下是创建外键并启用级联操作的示例：

```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(50)
);

CREATE TABLE orders (
  id INT PRIMARY KEY,
  user_id INT,
  order_date DATETIME,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

上述代码创建了两张表，orders表中的user_id列引用了users表中的id列，并启用了ON DELETE CASCADE级联操作。这意味着，如果在users表中删除一行，那么orders表中与之相关的行也将被删除。

需要注意的是，使用级联操作需要谨慎，因为它们可能会影响到整个数据库的完整性和一致性。在设计数据库时，需要根据具体需求来决定是否需要使用级联操作。

## Statement和PreparedStatement区别

在Java中，`Statement`和`PreparedStatement`都是用于执行SQL语句的接口，但它们在执行SQL语句时有所不同。

`Statement`接口用于执行静态SQL语句。每次执行SQL语句时，`Statement`都会将SQL语句发送到数据库进行编译和解析，并返回查询结果。这意味着对于每次执行，都需要重新编译和解析SQL语句，因此在执行多次相同SQL语句时，`Statement`的性能较差。

`PreparedStatement`接口用于执行预编译的SQL语句。在使用`PreparedStatement`时，SQL语句在第一次执行时就会被编译和解析，并且编译结果会被缓存起来。因此，当需要多次执行相同的SQL语句时，`PreparedStatement`的性能比`Statement`更高。

此外，由于`PreparedStatement`使用参数化查询，可以防止SQL注入攻击。使用`PreparedStatement`时，应该使用参数化查询，将输入的参数作为占位符，而不是将它们直接插入SQL语句中。

综上所述，如果需要多次执行相同的SQL语句或希望提高查询性能并防止SQL注入攻击，应该使用`PreparedStatement`。否则，可以使用`Statement`。

# 事务

> 蚂蚁

## 事务四大特性及实现方式

> 小米，百度，keep，京东，字节，万得，阿里，蚂蚁

事务是指一组操作，这些操作被视为一个整体，要么全部执行成功，要么全部失败回滚。事务通常用于保证数据库中数据的完整性和一致性。在关系型数据库中，事务具有四个基本属性，也称为 ACID 特性：

**原子性 atomicity**

MySQL事务的原子性是指一个事务中的所有操作，要么全部执行成功，要么全部执行失败回滚，不能只执行其中的一部分操作。MySQL通过undo log和redo log来实现事务的原子性。

MySQL通过**undo log**来实现事务的原子性，保证了一个事务中的所有操作要么全部执行成功，要么全部执行失败回滚，从而保证了数据的一致性。

在MySQL中，每个事务都有一个undo log。undo log用于撤销事务的操作，记录了一个操作的反向操作，以保证在事务回滚时能够正确地执行撤销操作。

**一致性 consistency**

事务执行的结果必须是使数据库从一个一致性状态变为另一个一致性状态。在事务开始前和结束后，数据库的完整性约束没有被破坏。

一致性主要是由其他三个特性来共同保证的。

**隔离性 isolation**

多个事务并发执行时，一个事务的执行不会影响其他事务的执行。每个事务都感觉不到其他事务的存在，即一个事务所做的修改在提交之前对其他事务是不可见的。

MySQL的事务隔离性是通过**锁机制**和**MVCC**（多版本并发控制）实现的。

锁机制主要分为两种：共享锁和排他锁。共享锁（S锁）和排他锁（X锁）是互斥的，即同时只能有一个事务持有某个数据行的S锁或X锁，但是S锁可以被多个事务持有。

MySQL的MVCC是通过记录版本号的方式实现的。当一个事务启动时，MySQL会为每个查询创建一个可见性视图，该视图定义了在该事务开始时可以看到哪些数据版本。MySQL将每个数据行的版本信息存储在数据行中，每个事务根据自己的可见性视图读取对应的版本，如果对应的版本号大于事务的可见性视图，则数据行对该事务不可见。

**持久性 durability**

一旦事务提交，其所做的修改就会永久保存到数据库中，并不会因为后续操作或故障而丢失。

MySQL 使用 **redo log** 来实现持久性。redo log 记录了所有对数据库的修改操作，当发生宕机等异常情况时，MySQL 可以使用 redo log 来重放之前的修改操作，从而将数据库恢复到最近一次正常关闭时的状态。

------

## 多条SQL如何保证一致性

> 蚂蚁

使用MySQL事务

1. 开始事务：使用SQL中的BEGIN TRANSACTION语句来开始一个新的事务。
2. 执行SQL操作：在事务内，执行需要保证一致性的多条SQL操作，可以是数据插入、更新、删除等操作。
3. 提交事务：在所有SQL操作都成功执行完成之后，使用SQL中的COMMIT语句来提交事务。这样可以将所有SQL操作的结果一起提交，保证它们的一致性。
4. 回滚事务：如果执行SQL操作的过程中出现了错误，可以使用SQL中的ROLLBACK语句来回滚事务，将所有SQL操作都撤销。这样可以保证数据库的一致性不会受到影响。

假设有一个在线商城系统，用户可以通过该系统下单购买商品。在这个系统中，需要确保用户下单后，商品的库存数量被正确地减少，同时用户的订单信息被正确地插入到订单表中。以下是使用事务来确保这两个操作的一致性的一个具体例子：

```sql
BEGIN TRANSACTION;  -- 开始事务

-- 更新商品库存数量
UPDATE products SET stock = stock - 1 WHERE product_id = 123;

-- 将订单信息插入到订单表中
INSERT INTO orders (user_id, product_id, order_time) VALUES (456, 123, '2023-03-23 10:00:00');

COMMIT;  -- 提交事务
```

在这个例子中，首先使用`BEGIN TRANSACTION`语句开始一个新的事务，然后执行两个SQL语句来更新商品库存数量和将订单信息插入到订单表中。如果两个操作都成功执行完成，那么就使用`COMMIT`语句来提交事务，这样两个操作的结果就会一起被提交到数据库中，确保它们的一致性。如果其中任何一个操作失败，整个事务就会被回滚，撤销之前的所有操作，从而确保数据的一致性不会受到影响。

## MySQL 事务的隔离级别

> 蔚来，百度，小米，京东，字节，美团，阿里钉钉，拼多多，度小满，滴滴，快手，万得，蚂蚁

**读未提交 READ UNCOMMITTED**

事务可以读取到其他事务未提交的数据，可能出现脏读、幻读和不可重复读等问题。

**读已提交 READ COMMITTED**

事务只能读取到其他事务已经提交的数据，可以避免脏读问题，但是仍可能出现幻读和不可重复读问题。

**可重复读 REPEATABLE READ**（MySQL默认的隔离级别）

在一个事务内，多次读取同一个数据会得到相同的结果。在这个级别下，可以避免脏读和不可重复读问题，但仍可能出现幻读问题。

**串行化 SERIALIZABLE**

事务必须串行执行，可以避免所有并发问题，但是会导致系统性能下降，因为每个事务都必须等待其他事务完成。

|     隔离级别     | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| READ-UNCOMMITTED |  √   |     √      |  √   |
|  READ-COMMITTED  |  ×   |     √      |  √   |
| REPEATABLE-READ  |  ×   |     ×      |  √   |
|   SERIALIZABLE   |  ×   |     ×      |  ×   |

------

## 造成幻读的原因了解吗

> 百度

## MVCC

> 字节，小米，快手，德胧，百度，阿里

MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。关于它的实现，要抓住几个关键点，**隐式字段、undo 日志、版本链、快照读&当前读、Read View**。

**版本链**

对于 InnoDB 存储引擎，每一行记录都有两个隐藏列**DB_TRX_ID、DB_ROLL_PTR**

- `DB_TRX_ID`，事务 ID，每次修改时，都会把该事务 ID 复制给`DB_TRX_ID`；
- `DB_ROLL_PTR`，回滚指针，指向回滚段的 undo 日志。

由于每次变动都会先把`undo`日志记录下来，并用`DB_ROLL_PTR`指向`undo`日志地址。因此可以认为，**对该条记录的修改日志串联起来就形成了一个`版本链`，版本链的头节点就是当前记录最新的值**。

**ReadView**

> 对于`Read Committed`和`Repeatable Read`隔离级别来说，都需要读取已经提交的事务所修改的记录，也就是说如果版本链中某个版本的修改没有提交，那么该版本的记录时不能被读取的。所以需要确定在`Read Committed`和`Repeatable Read`隔离级别下，版本链中哪个版本是能被当前事务读取的。于是就引入了`ReadView`这个概念来解决这个问题。

Read View 就是事务执行**快照读**时，产生的读视图，相当于某时刻表记录的一个快照，通过这个快照，我们可以获取：

- m_ids ：表示在生成 ReadView 时当前系统中活跃的读写事务的事务 id 列表。
- min_trx_id ：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的事务 id ，也就是 m_ids 中的最小值。
- max_trx_id ：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。
- creator_trx_id ：表示生成该 ReadView 的事务的事务 id

有了这个 ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

- 如果被访问版本的 DB_TRX_ID 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
- 如果被访问版本的 DB_TRX_ID 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。
- 如果被访问版本的 DB_TRX_ID 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。
- 如果被访问版本的 DB_TRX_ID 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成 ReadView 的时机不同。

READ COMMITTED 是**每次读取数据前都生成一个 ReadView**，这样就能保证自己每次都能读到其它事务提交的数据；REPEATABLE READ 是在**第一次读取数据时生成一个 ReadView**，这样就能保证后续读取的结果完全一致。

## MVCC的作用

> 字节，小米

MVCC（多版本并发控制）的主要作用是实现数据库系统中事务的隔离性和并发控制。在多用户、多事务同时访问数据库时，MVCC 可以保证每个事务所看到的数据是一致性的，并且多个事务可以并发执行而不会相互干扰，提高数据库的并发性能和可靠性。

## 如何解决幻读

> 字节，阿里钉钉

1. 调整隔离级别：将隔离级别提高到SERIALIZABLE，可以避免幻读问题，但是会对性能产生一定的影响。
2. 使用悲观锁：使用SELECT ... FOR UPDATE或SELECT ... FOR SHARE等悲观锁语句，可以锁定符合查询条件的数据，防止其他事务对数据进行修改，从而避免幻读问题。
3. `InnoDB` 使用 Next-key Lock（临键锁） 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。
4. 使用MVCC：使用多版本并发控制（MVCC）机制，在每个事务中保存一个快照，不会出现幻读问题。

------

## redolog和binlog的区别

> 蚂蚁

1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑。
3. redo log 是循环写的，空间固定会用完（4个文件，每个文件1Ｇ）；binlog 是可以追加写入的。“追加写”是指 binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

## undo log

> 蚂蚁

在 MySQL 中，undo log 是一种逻辑日志，用于回滚事务和 MVCC 机制的实现。在事务提交之前，MySQL 会将该事务对数据的修改操作记录到 undo log 中，如果该事务需要回滚，则可以根据 undo log 中的操作记录进行回滚操作，从而保证数据的一致性。

undo log 的实现原理主要包括以下几个步骤：

1. 在事务开始时，MySQL 会为该事务分配一个 undo log 区域，该区域用于记录该事务对数据的修改操作。
2. 在执行事务时，MySQL 会将该事务对数据的修改操作记录到 undo log 中，同时在数据页中记录该修改操作的 redo 日志。
3. 如果该事务需要回滚，则可以根据 undo log 中的操作记录进行回滚操作。MySQL 会按照相反的顺序执行 undo log 中的操作记录，将数据恢复到事务开始时的状态。
4. 如果该事务提交，则会将 undo log 中的操作记录删除，因为这些操作已经被记录到 redo 日志中了，可以根据 redo 日志来恢复数据。
5. 在 MVCC 机制中，undo log 还用于记录每个事务的启动时间和结束时间，以及每个事务对数据的修改操作。当其他事务要读取该数据时，可以根据该数据的版本号和 undo log 中的操作记录判断是否可见。

## binlog

> 蚂蚁

binlog是MySQL中另一个重要的日志文件，它记录了数据库中所有数据的变化操作，包括INSERT、UPDATE、DELETE等操作。binlog的作用是用于数据恢复、数据备份以及主从同步。在进行数据恢复时，可以通过读取binlog中的操作记录来还原数据。在进行主从同步时，主数据库会将变化记录写入binlog中，从数据库可以通过读取binlog来同步主数据库中的数据。

------

# MySQL 存储引擎

## MySQL 支持哪些存储引擎?

> 滴滴，美团，拼多多

MySQL存储引擎是MySQL用于管理和存储数据的核心组件，它们之间的区别主要在于性能、功能、支持的数据类型、锁定机制等方面。下面列举一些常见的MySQL存储引擎及其特点：

1. InnoDB存储引擎

InnoDB是MySQL 5.5.5及以后版本的默认存储引擎，支持事务、行级锁定和外键约束等高级特性。InnoDB存储引擎支持ACID事务模型，并且对高并发读写具有很好的性能。

2. MyISAM存储引擎

MyISAM存储引擎是MySQL 5.5.5及以前版本的默认存储引擎，不支持事务和行级锁定，但具有较高的查询性能和表级锁定。MyISAM存储引擎适用于数据量较大、读操作比写操作多的场景。

3. MEMORY存储引擎

MEMORY存储引擎是将数据存储在内存中的存储引擎，数据的读写速度非常快。但由于数据存储在内存中，当MySQL服务重启或崩溃时，数据将会丢失。MEMORY存储引擎适用于对性能要求非常高的缓存数据、临时表等场景。

4. NDB Cluster存储引擎

NDB Cluster存储引擎是MySQL的一种分布式存储引擎，它将数据分布在多个节点上，提供高可用性、高性能、数据分区和动态扩展等特性。NDB Cluster存储引擎适用于高可用性和高并发读写的大型应用。

5. ARCHIVE存储引擎

ARCHIVE存储引擎是一种高压缩比的存储引擎，适用于不经常更新但需要长期保存的历史数据。ARCHIVE存储引擎不支持索引和事务，但可以提供快速的数据备份和恢复。

6. CSV存储引擎

CSV存储引擎是将数据存储在CSV（逗号分隔值）格式的文件中的存储引擎。CSV存储引擎不支持索引、事务和外键约束，但可以将数据导入到其他数据库或软件中。

总体来说，选择适合的MySQL存储引擎需要根据应用场景、数据量、数据类型、并发访问等因素综合考虑，选取不同的存储引擎可以最大限度地提高MySQL的性能和可用性。

## MyISAM 和 InnoDB 的区别

> 百度，阿里，腾讯IEG，滴滴，字节，普元

InnoDB和MyISAM是MySQL中两种常见的存储引擎，它们之间有以下主要区别：

1. 事务支持：InnoDB支持事务处理，而MyISAM不支持事务处理。因此，如果需要支持事务或者需要保证数据的完整性和一致性，应该选择InnoDB。
2. 锁机制：InnoDB采用行级锁定，MyISAM采用表级锁定。行级锁定可以提高并发性能，避免数据修改时对整张表的锁定，而表级锁定会对整张表进行锁定，降低并发性能。
3. 性能：MyISAM在读取大量数据时比InnoDB更快，但在并发查询的情况下，InnoDB比MyISAM更快，因为InnoDB采用了行级锁定。
4. 容灾性：InnoDB支持崩溃恢复和自动恢复机制，而MyISAM不支持。
5. 索引：InnoDB支持聚集索引（clustered index），而MyISAM只支持非聚集索引（non-clustered index）。聚集索引将数据存储在索引的叶子节点中，因此可以避免回表操作，提高查询性能。

综上所述，如果需要支持事务、并发性能和容灾性能，则应该选择InnoDB存储引擎，如果只需要查询性能，则可以考虑使用MyISAM存储引擎。

------

## MyISAM 和 InnoDB 如何选择？

> 滴滴

大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点。

《MySQL 高性能》上面有一句话这样写到:

> 不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。

一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。

因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。

## InnoDB下有哪些物理结构

> 美团

InnoDB 是 MySQL 数据库系统的一个存储引擎，其物理结构主要包括以下几个部分：

1. 表空间文件（.ibd 文件）：每个 InnoDB 表对应一个或多个表空间文件，其中包含了表的数据和索引。
2. 表结构定义：在 InnoDB 中，每个表都会有一个 frm 文件，里面存储了该表的结构定义，包括列名、列的数据类型、约束等信息。
3. 行记录：InnoDB 中的数据存储是按行存储的，每个行记录存储了表中一行数据的所有列值。
4. 索引：InnoDB 支持多种类型的索引，包括 B+ 树索引、全文索引等，这些索引都会存储在表空间文件中。
5. 事务日志：InnoDB 通过事务日志（redo log）来保证数据的持久性和一致性，事务日志包括了事务执行过程中所做的修改操作。
6. 其他：还包括缓冲池、数据字典等。

这些物理结构相互协作，构成了 InnoDB 存储引擎的整体架构。

# MySQL锁

## MySQL有哪些锁？

> 蔚来，京东，美团，蚂蚁

![MySQL锁](E:\Typora\MySQL锁.png)

------

## 乐观锁与悲观锁

> 华为，唯品会，德胧，阿里，蚂蚁

悲观锁是指在对数据进行操作时，先对数据进行加锁，确保其他事务无法修改该数据，待当前事务完成后再释放锁。悲观锁的思想是假设最坏的情况，即假设数据随时会被其他事务修改，因此需要一直占用锁。悲观锁的实现方式有两种：共享锁和排他锁。

乐观锁则是在对数据进行操作时，先不加锁，而是在最后一刻再检查是否有其他事务修改了数据。如果有，那么当前事务不进行提交，而是进行重试或者回滚操作。乐观锁的实现方式一般是在数据表中增加一个版本号或者时间戳字段，每次操作都会检查该字段是否与预期值相等，如果不相等，则说明该数据已经被其他事务修改过了。

悲观锁适用于并发量比较大、并发冲突比较频繁的场景，而乐观锁适用于并发量比较小、并发冲突比较少的场景。

## MySQL乐观锁实现

> 蚂蚁

MySQL并没有原生支持乐观锁的实现，但可以通过版本号（version）或时间戳（timestamp）等方式手动实现乐观锁。下面以版本号为例，介绍乐观锁在MySQL中的实现方法：

1. 添加版本号列

在需要使用乐观锁的表中添加一个版本号列，类型可以是整型或时间戳类型。

例如，我们在 `user` 表中添加一个名为 `version` 的整型列，初始值设为 0。

```sql
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `age` int(11) NOT NULL,
  `version` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

2. 在SQL语句中使用版本号

在更新记录时，将版本号列加入更新条件中，只有当版本号和预期值一致时，才进行更新操作。

例如，我们想要更新 id 为 1 的用户的年龄为 20，那么我们可以使用以下SQL语句：

```sql
UPDATE `user` SET `age` = 20, `version` = `version` + 1 WHERE `id` = 1 AND `version` = 0;
```

其中，`version = version + 1` 是为了更新版本号。

3. 处理乐观锁异常

当更新失败时，说明版本号已被修改，需要进行相应的处理。在Java中，可以使用 `java.sql.SQLException` 捕获乐观锁异常。

```java
try {
    // 执行更新操作
    // ...
} catch (SQLException e) {
    // 处理乐观锁异常
    // ...
}
```

4. 注意事项

使用乐观锁需要注意以下几点：

- 版本号的初始值应为 0，每次更新时需要将版本号加 1。
- 每次更新只能更新一条记录，否则会出现并发问题。
- 如果乐观锁操作频繁出现，会增加系统的开销，影响性能。因此，需要根据具体场景进行权衡，选择适当的锁机制。

## MySQL怎么处理并发问题的？

> 蚂蚁

MySQL处理并发问题的主要方式是通过锁机制来保证数据的一致性和可靠性。MySQL提供了多种类型的锁，包括共享锁和排他锁等，用于不同场景下的并发控制。

下面是MySQL处理并发问题的一些常见技术：

1. 表锁和行锁：MySQL中的表锁和行锁分别用于对整个表和表中的行进行锁定。表锁适用于并发较低的场景，锁定整个表，保证操作的原子性；行锁适用于并发较高的场景，只锁定需要操作的行，减少锁的冲突，提高并发性能。
2. 事务隔离级别：MySQL提供了多种事务隔离级别，用于控制不同事务之间的并发性。常见的事务隔离级别包括读未提交、读已提交、可重复读和串行化等。不同的隔离级别对锁的粒度和冲突的处理方式不同，需要根据实际需求选择合适的隔离级别。
3. MVCC：MySQL使用MVCC（Multi-Version Concurrency Control）技术来处理读写冲突。MVCC通过版本号来区分不同事务之间的数据，并且在读操作中不会阻塞写操作，从而提高了并发性能。
4. 锁优化：MySQL提供了多种锁优化技术，例如间隙锁、next-key锁和表达式索引等，用于减少锁的冲突和提高并发性能。

需要注意的是，MySQL处理并发问题不是一件简单的事情，需要综合考虑多个因素，例如数据量、并发量、系统硬件性能、SQL语句的优化等，以达到最佳的性能和稳定性。

## 数据库的行锁和表锁，他们分别解决的问题

> zoom，蚂蚁

行锁：

行锁是指针对数据库中的某一行数据进行加锁，保证同时只有一个事务可以对该行进行修改，其他事务必须等待该事务的提交或回滚后才能对该行进行修改。行锁的粒度比较小，锁定的是某一行数据，因此它可以保证并发访问数据库时的数据一致性，避免了出现脏读、不可重复读、幻读等问题。行锁一般用于高并发场景下，对于经常被访问的数据行，使用行锁可以最大限度地提高数据库的并发性能。

表锁：

表锁是指针对数据库中的某个表进行加锁，保证同时只有一个事务可以对该表进行修改，其他事务必须等待该事务的提交或回滚后才能对该表进行修改。表锁的粒度比较大，锁定的是整个表，因此它的粒度比行锁要大，而且它的并发性能比行锁要低，因为只要有一个事务修改了该表，其他事务就必须等待。表锁一般用于低并发场景下，对于不经常被访问的表，使用表锁可以避免大量的行锁竞争，从而提高数据库的性能。

------

## 如何加表锁和行锁，分别的底层了解吗？

> 蚂蚁

在关系型数据库中，可以通过表锁和行锁来保证数据的一致性和并发访问的正确性。

### 表锁

表锁是指对整张表进行加锁，可以防止其他事务修改整张表中的任何一行数据。在数据库引擎中，表锁通常实现为一个互斥锁（Mutex），当一个事务获得了表锁后，其他事务必须等待该事务释放锁才能继续执行。表锁的优点是简单、效率高，缺点是锁粒度较大，可能会造成锁冲突，降低并发性能。

在 MySQL 中，可以使用 `LOCK TABLES` 命令对表进行加锁，例如：

```sql
LOCK TABLES mytable WRITE;
```

上述语句会将 `mytable` 表加写锁，其他事务无法对该表进行写操作。

### 行锁

行锁是指对表中某一行进行加锁，可以防止其他事务修改该行数据，但不影响其他行的访问。在数据库引擎中，行锁通常实现为一个轻量级的锁对象，每行数据都有一个对应的锁对象，当事务需要修改某行数据时，会首先获得该行数据对应的锁对象。行锁的优点是锁粒度较小，可以提高并发性能，缺点是实现复杂，对数据库性能的影响较大。

在 MySQL 中，可以使用 `SELECT ... FOR UPDATE` 或 `SELECT ... FOR SHARE` 语句对行进行加锁，例如：

```sql
SELECT * FROM mytable WHERE id = 1 FOR UPDATE;
```

上述语句会将 `mytable` 表中 `id` 为 1 的行加写锁，其他事务无法修改该行数据。如果希望其他事务可以读取该行数据，可以使用 `SELECT ... FOR SHARE` 语句，例如：

```sql
SELECT * FROM mytable WHERE id = 1 FOR SHARE;
```

上述语句会将 `mytable` 表中 `id` 为 1 的行加读锁，其他事务无法对该行进行写操作，但可以进行读操作。

需要注意的是，表锁和行锁在不同的场景下有不同的应用，需要根据实际情况选择合适的锁粒度。同时，加锁操作可能会对数据库性能产生影响，需要谨慎使用。

## next-key lock（临键锁）

Next-key lock是MySQL数据库中的一种特殊的锁类型，它结合了记录锁和间隙锁的特点。在InnoDB存储引擎中，当使用可重复读或者序列化隔离级别时，MySQL会自动为查询语句加上next-key lock，以保证数据的一致性。

Next-key lock的作用是防止幻读。当一个事务执行一个范围查询时，MySQL会为范围内的每一条记录加上next-key lock，以保证在此期间没有其他事务能够插入符合查询条件的新数据，从而避免了幻读的问题。

## 共享锁和排他锁

> 蔚来

SELECT 的读取锁定主要分为两种方式：共享锁和排他锁。

```mysql
select * from table where id<6 lock in share mode;--共享锁
select * from table where id<6 for update;--排他锁
```

共享锁和排他锁是MySQL中常见的锁类型，用于控制并发访问时对数据的读写操作。

共享锁是读锁，也称为S锁，多个事务可以同时持有共享锁，并发读取相同的数据，但不能进行写操作。在MySQL中，共享锁可以使用SELECT语句中的LOCK IN SHARE MODE或FOR SHARE子句来获取。

排他锁是写锁，也称为X锁，只有一个事务可以持有排他锁，进行写操作，其他事务无法同时持有共享锁或排他锁，保证了数据的完整性和一致性。在MySQL中，排他锁可以使用UPDATE、DELETE和INSERT语句来获取，也可以使用SELECT语句中的FOR UPDATE子句来获取。

## 意向锁有什么作用？

如果需要用到表锁的话，如何判断表中的记录没有行锁呢？一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。

意向锁是表级锁，共有两种：

- **意向共享锁（Intention Shared Lock，IS 锁）**：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。
- **意向排他锁（Intention Exclusive Lock，IX 锁）**：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。

意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。

意向锁之间是互相兼容的。

|       | IS 锁 | IX 锁 |
| ----- | ----- | ----- |
| IS 锁 | 兼容  | 兼容  |
| IX 锁 | 兼容  | 兼容  |

意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。

|      | IS 锁 | IX 锁 |
| ---- | ----- | ----- |
| S 锁 | 兼容  | 互斥  |
| X 锁 | 互斥  | 互斥  |

------

## 什么时候会使用区间锁？

> 字节

区间锁是指在数据库中针对一个区间（range）的数据进行加锁操作。通常情况下，区间锁用于保证一段连续的数据访问时的一致性和并发性。

使用区间锁的场景包括以下几种情况：

1. 线程需要同时锁定多个相邻的数据项，例如锁定一段时间范围内的订单记录。
2. 多个线程需要访问同一个区间的数据，而每个线程又需要以不同的顺序访问这些数据，例如对一段时间范围内的数据进行统计计算。
3. 多个线程需要同时读取同一个区间的数据，而且需要保证读取数据的一致性和完整性。

在这些场景下，使用区间锁可以提高并发访问的效率，同时保证数据的一致性和完整性。但是，在使用区间锁时需要注意，由于锁的范围比较大，如果多个线程同时访问同一个区间的数据，可能会出现死锁等问题。因此，在使用区间锁时，需要仔细设计和调试代码，以保证其正确性和可靠性。

## 当前读和快照读有什么区别？

> 蔚来，百度

**快照读**（一致性非锁定读）就是单纯的 `SELECT` 语句，但不包括下面这两类 `SELECT` 语句：

```sql
SELECT ... FOR UPDATE
SELECT ... LOCK IN SHARE MODE
```

快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。

快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。

只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：

- 在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。
- 在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。

快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。

**当前读** （一致性锁定读）就是给行记录加 X 锁或 S 锁。

当前读的一些常见 SQL 语句类型如下：

```sql
# 对读的记录加一个X锁
SELECT...FOR UPDATE
# 对读的记录加一个S锁
SELECT...LOCK IN SHARE MODE
# 对修改的记录加一个X锁
INSERT...
UPDATE...
DELETE...
```

------

# 索引

> 百度，zoom，美团，蔚来

## MySQL索引分类

> 字节TikTok，唯品会，百度，阿里，蚂蚁，美团

从三个不同维度对索引分类：

![索引分类](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/mysql-f650c0b8-9ebe-4e17-ac7e-b8eb121756a1.jpg)

MySQL索引类型主要包括以下几种：

1. 主键索引：用于唯一标识每一行数据，表中只能有一个主键索引。主键索引可以是单个字段或多个字段的组合。主键索引的好处是可以加速数据检索和数据操作，而且避免了数据冗余和不一致。
2. 唯一索引：保证索引列的值唯一，可以有多个唯一索引。唯一索引的好处是可以提高数据的查询效率，避免数据冲突和重复。
3. 普通索引：最基本的索引类型，没有任何限制。可以加速数据的检索，但是不能保证索引列的唯一性。
4. 全文索引：用于全文搜索，主要用于文本类型的数据。全文索引可以加速数据的模糊查询和搜索，但是需要消耗大量的存储空间和计算资源。
5. 组合索引：即联合索引，是在多个列上创建的索引，可以提高数据的检索效率。组合索引的建立需要考虑查询的频率和字段的大小等因素，避免创建无用的索引。
6. 空间索引：用于地理信息和空间数据的检索，可以加速数据的范围查询和空间关系查询。空间索引可以加速地理位置服务、交通导航和电子地图等应用。

不同类型的索引在实际应用中有不同的适用场景，需要根据具体情况选择合适的索引类型进行优化。同时，索引的设计和优化也需要考虑数据库的存储引擎、数据类型、数据量、查询方式等因素。

## 数据库加了索引为啥会变快

> 蚂蚁

在数据库中，索引是一种数据结构，它可以提高数据库查询的效率。当我们在某个表的一个或多个列上创建索引后，数据库就可以使用这些索引来快速查找符合特定条件的数据行，而不必扫描整个表的所有数据。

具体来说，索引可以带来以下优点：

1. 减少数据访问的次数。使用索引可以快速定位到符合特定条件的数据行，减少了查询时需要扫描的数据量，从而提高了查询的速度。
2. 减少排序的开销。当查询结果需要排序时，使用索引可以减少排序的开销，因为索引本身已经按照特定的顺序排好了。
3. 提高数据的一致性和完整性。在创建索引时，我们可以指定某些列的唯一性、非空性等约束条件，这些约束条件可以保证数据的一致性和完整性。

需要注意的是，索引并不是万能的，过多的索引也可能会影响数据库的性能。因为索引需要占用额外的存储空间，并且在插入、更新和删除数据时需要维护索引的结构，会增加数据库的负载。因此，在创建索引时，需要仔细考虑查询的频率和数据的变化率，以及对查询性能的影响等因素，权衡索引的利弊，避免创建不必要的索引。

## 索引的优缺点

> 英雄游戏，蚂蚁

**优点** ：

- 使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

**缺点** ：

- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。

但是，**使用索引一定能提高查询性能吗?**

大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。

## 为什么用B+树而不用B树

> 字节，百度，英雄游戏，小米，京东，阿里，滴滴，德胧，拼多多，蚂蚁

1. B+ 树所有的数据存储在叶子节点，非叶子节点只存储索引，因此相比 B 树可以存储更多的索引项，使得树的高度更低，**查询效率更高**。
2. B+ 树的叶子节点都被连接成一个双向链表，因此在范围查询时更加高效，可以直接遍历整个链表。而在 B 树中，需要通过非叶子节点进行查找，查询效率相对较低。
3. B+树查询效率更稳定。B+树每次都必须查询到叶子节点才能找到数据，而B树查询的数据可能不在叶子节点，也可能在，这样就会造成查询的效率的不稳定。

## 了解 Hash 索引吗？

> 字节

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

只有 Memory 引擎显式支持哈希索引，这也是 Memory 引擎的默认索引类型。

因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引的速度非常快，但它也有一些限制：

- 哈希索引数据不是按照索引值顺序存储的，无法用于排序。
- 哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如在数据列(a,b)上建立哈希索引，如果查询的列只有a就无法使用该索引。
- 哈希索引只支持等值比较查询，不支持任何范围查询。

------

## 聚簇索引与非聚簇索引

> 小米，阿里，美团，字节，百度

### 聚簇索引

聚簇索引是一种将表的数据和索引数据存储在一起的索引结构，它是按照索引的列值对表中的数据进行物理排序，因此表中的数据在磁盘上是连续存储的。聚簇索引只能有一个，通常情况下是通过定义主键来实现的，也可以通过指定某个唯一索引来创建聚簇索引。

聚簇索引的优点是：

- 可以提高数据检索的速度，因为表中的数据在磁盘上是连续存储的，可以减少磁盘读取次数。
- 可以提高数据插入的速度，因为新数据可以直接插入到表的末尾，不需要进行额外的排序操作。

聚簇索引的缺点是：

- 当频繁进行插入、更新或删除操作时，可能会导致数据的物理排序发生变化，从而导致性能下降。
- 索引的大小通常比较大，因为它包含了所有的表数据。

### 非聚簇索引

非聚簇索引是一种将索引数据和表数据分开存储的索引结构，它通常包含索引列的值和一个指向对应行的指针。因此，当使用非聚簇索引进行数据检索时，需要先根据索引列的值找到对应的行指针，再根据行指针去访问实际的数据。

非聚簇索引的优点是：

- 可以减少磁盘空间的占用，因为索引不包含所有的表数据。
- 当频繁进行插入、更新或删除操作时，不会对数据的物理排序产生影响。

非聚簇索引的缺点是：

- 检索速度通常比聚簇索引慢，因为需要进行额外的磁盘访问。
- 可能会产生“回表”操作，即在索引中查找到行指针后，还需要通过行指针去访问实际的数据，会导致额外的磁盘访问。

综上所述，聚簇索引适合于频繁进行数据查询的表，而非聚簇索引适合于频繁进行数据插入、更新或删除的表。在实际应用中，可以根据具体的业务场景来选择适合的索引类型。

#### 非聚簇索引一定回表查询吗(覆盖索引)?

**非聚簇索引不一定回表查询。**

试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。

```sql
 SELECT name FROM table WHERE name='guang19';
```

那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。

即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！**如果 SQL 查的就是主键呢?**

```sql
SELECT id FROM table WHERE id=1;
```

主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。

## 回表

> 字节

回表是指在使用非聚簇索引查询时，MySQL 需要在索引树中查找到相应的主键值，然后再通过主键值到聚簇索引中查找相应的行数据，这个过程称为“回表”。

回表操作会对性能产生一定的影响，因为需要进行两次查询操作，而且需要从索引树上查找到相应的主键值，然后再到聚簇索引上查询相应的行数据，涉及到磁盘 IO 操作。

## 覆盖索引

> 百度，滴滴，字节，亚信

覆盖索引是指在使用索引查询时，MySQL 能够直接从索引树中获取所需的数据，而不需要回到聚簇索引中查询相应的行数据。这种情况下，MySQL 不需要回表，因为查询所需的数据已经包含在索引中了，这个过程称为“覆盖索引”。

覆盖索引可以提高查询的效率，因为不需要回表，避免了涉及到磁盘 IO 的操作，而且能够减少查询的数据量，提高查询速度。

## 联合索引

> 字节，唯品会

MySQL联合索引是指在多个列上创建的索引，也称为复合索引或组合索引。联合索引可以提高多列组合条件下的查询速度，减少数据库的访问次数和IO操作，提高查询效率。

与单列索引相比，联合索引有以下几个优点：

1. 提高查询效率：联合索引可以同时匹配多个列，可以更快地过滤掉不符合条件的数据行，从而提高查询效率。
2. 减少IO操作：联合索引可以减少数据库的访问次数和IO操作，因为可以将多个列的数据存储在同一个索引中，减少访问磁盘的次数。
3. 覆盖查询：如果联合索引包含了所有需要查询的列，就可以使用覆盖查询，避免了对表的访问和IO操作，进一步提高查询效率。

在创建联合索引时，需要注意以下几点：

1. 列顺序：联合索引的列顺序需要根据具体查询的需求进行优化，把最常用的查询条件放在前面，可以提高查询效率。
2. 索引宽度：联合索引的列宽度不能太大，否则会增加索引的大小，导致查询效率降低。
3. 索引选择：不是所有的列都适合用于联合索引，需要根据具体的业务需求和数据特征选择合适的列进行索引。

在实际应用中，需要根据具体的查询需求和数据特征选择合适的索引类型和列，避免索引和数据的冗余和重复，以提高数据库的性能和可靠性。同时，需要注意定期维护索引，避免索引失效和占用过多的存储空间。

## 最左前缀匹配原则

> 英雄游戏，浪潮

最左前缀匹配原则指的是，在使用联合索引时，**MySQL** 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 **`>`**、**`<`**、**`between`** 和 **`以%开头的like查询`** 等条件，才会停止匹配。

所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

------

## 索引失效的情况有哪些？

> 百度，京东，美团，亚信

1. 在联合索引的场景下，查询条件不满足最左匹配原则
2. 使用了select *
3. 函数操作索引字段：如果查询语句中对索引字段进行了函数操作，那么索引也会失效，查询将变成全表扫描。
4. LIKE 以 % 开头：如果查询语句中使用了 LIKE 操作符以 % 开头，那么索引也会失效。因为 % 开头的模糊查询需要对所有索引值进行比对，无法利用索引加速。
5. 参数类型与字段类型不匹配，导致类型发生了隐式转换，索引失效
6. 查询条件使用or关键字，其中一个字段没有创建索引，则会导致整个查询语句索引失效
7. 对索引列使用!=或<>操作符，这会导致索引失效。

## 设置索引有什么注意的地方

> 美团，字节，阿里云

### 选择合适的字段创建索引

- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

### 被频繁更新的字段应该慎重建立索引

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

### 限制每张表上的索引数量

索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。

因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。

### 尽可能的考虑建立联合索引而不是单列索引

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

### 注意避免冗余索引

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

### 字符串类型的字段使用前缀索引代替普通索引

前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。

### 避免索引失效

索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：

- 使用 `SELECT *` 进行查询;
- 创建了组合索引，但查询条件未准守最左匹配原则;
- 在索引列上进行计算、函数、类型转换等操作;
- 以 `%` 开头的 LIKE 查询比如 `like '%abc'`;
- 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;
- 发生隐式转换;

### 删除长期未使用的索引

删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。

MySQL 5.7 可以通过查询 `sys` 库的 `schema_unused_indexes` 视图来查询哪些索引从未被使用。

## 索引下推

索引条件下推优化`（Index Condition Pushdown (ICP) ）`是 MySQL5.6 添加的，用于优化数据查询。

- 不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给 MySQL Server，MySQL Server 进行过滤条件的判断。
- 当使用索引条件下推优化时，如果过滤条件里有一些列没有用到索引，但建立了联合索引，MySQL Server 将这一部分列对应的判断条件**下推**给存储引擎，存储引擎先按照条件过滤一遍，然后再将过滤后的数据返回给 MySQL 服务器。

索引条件下推优化可以减少存储引擎回表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。MySQL执行计划中`Extra`一列里出现`Using index condition`说明用到了索引下推。

```sql
set optimizer_switch='index_condition_pushdown=on';	# 开启索引下推
```

# 优化

------

## 有哪些优化 SQL 的策略？

> 万得，美团

1.使用索引：确保表的字段都有索引，这样能够加速查询操作。

2.优化表的设计：如果表的设计不够合理，需要对表进行优化，例如拆分大表，将字段拆分为多个表等。

3.尽量减少子查询和连接操作：尽量减少 SQL 查询中的子查询和连接操作，这样能够加速查询速度。

4.优化查询条件：尽量让查询条件更加精确，例如使用等于（=）操作符代替 IN 操作符。

5.减少对大数据量表的查询：当查询大数据量表时，应该尽量减少返回的数据量，只返回必要的数据。

6.使用视图：视图可以将多个表的查询结果合并在一起，从而加速查询速度。

7.使用存储过程：存储过程能够将 SQL 语句预编译，减少 SQL 执行的时间，从而加速查询速度。

8.使用缓存：在查询频繁的情况下，可以将查询结果缓存起来，下次查询时直接从缓存中取数据，从而加快查询速度。

## MySQL慢查询怎么排查，怎么处理

> 阿里云，美团，渤海银行总行，万得，唯品会，蚂蚁

1. 开启慢查询日志

MySQL慢查询日志可以记录执行时间超过指定阈值的SQL语句，可以帮助我们找到执行效率低下的SQL语句。在MySQL配置文件中可以开启慢查询日志，具体操作如下：

```shell
# 打开MySQL配置文件
vi /etc/my.cnf

# 在 [mysqld] 段中添加以下配置
slow_query_log = ON
slow_query_log_file = /var/log/mysql/slow_query.log
long_query_time = 1

# 重启MySQL服务
systemctl restart mysqld
```

其中，`slow_query_log`配置项表示开启慢查询日志，`slow_query_log_file`配置项表示指定慢查询日志的输出位置，`long_query_time`配置项表示定义查询时间超过多少秒的查询为慢查询。

2. 查看慢查询日志

可以使用以下命令查看慢查询日志：

```shell
mysqldumpslow -t 10 /path/to/slow_query.log
```

其中，-t表示只显示前10个慢查询。

3. 分析慢查询

通过分析慢查询，可以找到执行时间较长的SQL语句，并了解它们的执行计划、索引使用情况、锁情况等信息，从而找到优化的方向。

4. 优化慢查询

根据分析结果，可以采取以下措施进行优化：

- 添加合适的索引
- 优化查询语句，避免全表扫描、大量的排序和分组操作等
- 使用缓存、预编译语句等技术，减少SQL语句的执行次数
- 调整数据库参数，如调整缓冲区大小、并发连接数等

5. 测试优化效果

优化后，需要进行测试验证优化效果是否明显，如果效果不理想，可以继续分析慢查询，找到其他优化方向。

## MySQL explain

> 唯品会，蔚来，德胧，蚂蚁，美团

MySQL explain是一种用于查询优化的工具，可以帮助开发人员和数据库管理员分析查询语句的执行计划，找出慢查询的瓶颈，进而对查询进行优化。通过执行explain语句可以获取MySQL的查询执行计划，并提供一些关于查询执行的额外信息，如使用了哪些索引、使用了哪些连接方式、哪些表被扫描、扫描的行数、执行的顺序等等。

MySQL explain的结果通常包含以下列：

1. id：查询的唯一标识符，包含一个或多个数字，标识执行查询的顺序。

2. select_type：查询类型，如简单查询、联合查询、子查询等。

3. table：显示查询涉及的表和它们的别名。

4. partitions：显示查询涉及的分区。

5. type：访问表的方式。

   - `const`：使用常数值匹配查询，通常只能匹配一行数据。
   - `eq_ref`：类似于const，使用唯一索引匹配查询，但是可以匹配多行数据。
   - `ref`：使用非唯一索引匹配查询，返回匹配某个单独值的所有行，通常会扫描索引树。
   - `range`：使用索引范围匹配查询，例如`WHERE`语句包含了一个`BETWEEN`、`<`、`>`等操作符。
   - `index`：全索引扫描，遍历整个索引树来匹配查询。
   - `ALL`：全表扫描，遍历整个表来匹配查询。

   通常情况下，访问类型的优先级从高到低依次是：`const`、`eq_ref`、`ref`、`range`、`index`、`ALL`。因此，如果查询的访问类型是`ALL`，就表示查询的性能可能存在较大问题，需要进行优化。

6. possible_keys：显示MySQL可以使用哪些索引来执行查询。

7. key：实际使用的索引，如果没有使用索引，则为NULL。

8. key_len：使用的索引的长度。

9. ref：显示哪些列或常量与索引一起使用。

10. rows：估计扫描的行数。

11. filtered：根据WHERE条件和表统计信息，MySQL过滤后扫描的行数占总扫描行数的百分比。

12. Extra：显示有关MySQL执行查询的详细信息，如使用了哪些连接方式、使用了哪些临时表、是否使用了文件排序等等。

    - `Using index`：表示查询使用了覆盖索引，查询可以直接从索引中获取数据，而无需读取表数据。
    - `Using where`：表示查询使用了`WHERE`子句中的条件过滤。
    - `Using temporary`：表示查询需要使用临时表，例如`GROUP BY`或`ORDER BY`操作需要创建临时表。
    - `Using filesort`：表示查询需要进行文件排序，例如`ORDER BY`操作不能使用索引排序。
    - `Using join buffer (Block Nested Loop)`：表示使用了连接缓冲区（Block Nested Loop）来处理连接操作。
    - `Using index condition`：表示查询使用了索引下推优化，可以将索引扫描和条件过滤合并在一起，从而减少访问表的次数。

    `extra`字段的值可以帮助我们进一步优化查询语句。例如，如果查询使用了临时表或文件排序，就可能会影响查询性能，可以考虑优化查询语句或添加索引等措施来提升查询性能。

使用explain语句可以查看查询的执行计划和相关信息，从而进行优化。例如，可以查看是否使用了索引、是否出现了全表扫描等低效查询方式，进而针对性地进行优化。同时，也可以结合其他性能监控工具，如慢查询日志、性能分析工具等，全面分析和优化MySQL的性能。

## 如何查看一条SQL语句走了哪些索引？

> 美团

在MySQL中，可以使用`EXPLAIN`关键字来查看一条SQL语句的执行计划，从而确定该语句走了哪些索引。具体步骤如下：

1. 在要执行的SQL语句前加上`EXPLAIN`关键字。
2. 执行该语句。
3. 查看结果中的`key`列，该列会显示这个查询中使用的索引。
4. 如果有多个索引，MySQL会选择其中一个来执行查询，可以查看`Extra`列来确定MySQL使用的是哪个索引。

例如，假设要查询一个名为`user`的表中`age`大于30的记录，可以这样写SQL语句并使用`EXPLAIN`关键字：

```sql
EXPLAIN SELECT * FROM user WHERE age > 30;
```

执行上述语句后，MySQL会返回一个包含查询执行计划的结果集。其中，如果`key`列中显示了一个或多个索引，就表示该查询使用了这些索引。

# SQL

## SQL注入问题及解决

> 腾讯IEG

所谓SQL注入(sql inject)，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。

解决：利用PreparedStatement先预编译对象，它是Statement的子类。
特点：性能高；预先编译好sql语句；sql语句中的参数会发生变化，过滤掉用户输入的关键字。

## if exists和if not exists

> 上海银行苏州研发中心

**1.介绍**
if not exists 即如果不存在，if exists 即如果存在

**2.使用**
a.判断数据库不存在时
if not exists（select * from sys.databases where name = ‘database_name’）

b.判断表不存在时
if not exists (select * from sysobjects where id = object_id(‘table_name’) and OBJECTPROPERTY(id, ’IsUserTable’) = 1)

c.判断列不存在
if not exists （select * from syscolumns where id=object_id(’table_name’) and name=’column_name’）

当判断的表不存时，我可以执行创建数据库，创建表，增加列，可以执行相应的SQL语句；
而if exists同理判断，首先判断查询结果是否存在，如果存在执行判断后面的语句，查询的数据库，表，列的方法相同；

## having和where区别？分别在sql语句中的位置？

> 美团

`HAVING`和`WHERE`都是SQL语句中用于筛选数据的关键字，不同的是`HAVING`关键字在分组之后对组进行筛选，而`WHERE`关键字在进行分组之前对原始数据进行筛选。

具体来说，`WHERE`关键字用于在查询语句中设置筛选条件，对原始数据进行过滤，它在查询中起到的是一个筛选的作用，只有满足条件的记录才会被查询出来，而不符合条件的记录将被排除掉。`WHERE`关键字在`FROM`子句之后、`GROUP BY`子句之前使用。

`HAVING`关键字用于在查询语句中对分组进行过滤，对分组后的结果进行筛选，它在分组后起到的是一个筛选的作用，只有满足条件的组才会被查询出来，而不符合条件的组将被排除掉。`HAVING`关键字在`GROUP BY`子句之后、`SELECT`子句之前使用。

举个例子来说，如果要查询一个学生的平均分数大于80分的班级名称和平均分数，可以这样写：

```
sqlCopy codeSELECT class_name, AVG(score) AS avg_score 
FROM student 
GROUP BY class_name 
HAVING avg_score > 80;
```

在这个查询中，`WHERE`关键字不能用于筛选平均分数大于80的分组，因为`AVG`是一个聚合函数，它会在分组之后才会进行计算，而`WHERE`只能在分组之前进行筛选。因此，这里需要使用`HAVING`关键字对分组进行筛选。

## SQL常见约束

> 上海银行苏州研发中心

① 主键约束：唯一标示，不能重复，不能为空。

> 1）主键应当是对用户没有意义的，一般都叫id
> 2）永远也不要更新主键，自动编号
> 3）主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等。
> 4）主键应当由计算机自动生成，一般配合auto_increment自动增长

自动增长：

> 我们可以在表中使用 auto_increment（自动增长列）关键字，自动增长列类型必须是整型，自动增长列必须为键(一般是主键)。

② 非空约束：

> NOT NULL 约束强制列不接受 NULL 值。

③ 唯一约束：

> UNIQUE 约束唯一标识数据库表中的每条记录。
> UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
> PRIMARY KEY 拥有自动定义的 UNIQUE 约束。

④ 默认值约束

> default 默认值

⑤ 外键约束：

> 多表关联字段、在一个表中是主键，在另外一个表中是非主键（则这个字段一般就称之外键）

## 使用视图有哪些好处

> 交通银行合肥研发

视图允许您定制对数据库中数据的访问。定制访问有以下几个好处：

- **有效地利用资源**  常规视图不需要额外的数据存储空间；每次调用这些视图时都会对其重新计算。实例化视图需要磁盘空间，但每次调用时不必重新计算。当数据库很大并且数据库服务器要处理频繁、重复的连接相同表的请求时，实例化视图可以缩短响应时间。
- **提高安全性**  因为可以只允许访问相关的信息。
- **提高可用性**  因为可以以一种比基表中的数据更易于理解的格式向用户和应用程序开发人员提供数据。
- **提高一致性**  因为可以在数据库中集中一般查询的定义。

## 触发器是用来干啥的，怎么创建触发器

> 交通银行合肥研发

触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指 用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生 了，就会 自动 激发触发器执行相应的操作。 

当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来 实现。

创建触发器的语法结构是：

```sql
CREATE TRIGGER 触发器名称 
{BEFORE|AFTER} {INSERT|UPDATE|DELETE} ON 表名 
FOR EACH ROW 
触发器执行的语句块;
```

 说明： 表名 ：表示触发器监控的对象。 BEFORE|AFTER ：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。 INSERT|UPDATE|DELETE ：表示触发的事件。 INSERT 表示插入记录时触发； UPDATE 表示更新记录时触发； DELETE 表示删除记录时触发

## 数据库范式及其意义

> 交通银行合肥研发，阿里云

数据库范式是关系型数据库设计中的一种规范化设计，通过将数据分解为不同的表，以避免冗余数据和数据不一致的问题，从而提高数据存储的效率和可靠性。

目前常用的数据库范式有以下几种：

1. 第一范式（1NF）：所有属性都是原子性的，即属性不可再分。该范式的要求是关系表中每个字段都必须是原子性的，不能再分解。
2. 第二范式（2NF）：满足第一范式的前提下，非主键属性完全依赖于主键，而不是依赖于主键的一部分。即关系表中的非主键字段都必须完全依赖于主键。
3. 第三范式（3NF）：满足第二范式的前提下，非主键属性之间不存在传递依赖关系。即关系表中的非主键字段之间不能有依赖关系，如果有，则需要分离成不同的表。
4. 巴斯-科德范式（BCNF）：满足第三范式的前提下，任何决定因素都是关系的候选键。即关系表中任何决定因素都必须是候选键。

范式设计的优点在于能够保证数据的一致性、减少冗余数据的存储，提高数据的检索效率。但是，过度的规范化设计可能会导致数据表的数量增多，关联查询的复杂度也会随之增加，因此在实际应用中需要权衡考虑。

## MySQL中char和varchar的区别？

> 美团

1. 存储方式：CHAR是定长的，VARCHAR是变长的。例如，如果一个CHAR(10)列中存储的数据不到10个字符，则在存储时会使用空格来填充剩余的位置，而VARCHAR则只会存储实际输入的数据，不会填充空格。
2. 用途：CHAR适用于存储长度固定的数据，例如性别、国籍等信息。而VARCHAR适用于存储长度不固定的数据，例如邮件地址、用户名等。

## 自连接和外连接

> 普元

### 自连接

自连接可以看成内连接的一种，只是连接的表是自身而已。

一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。

子查询版本

```sql
SELECT name
FROM employee
WHERE department = (
      SELECT department
      FROM employee
      WHERE name = "Jim");
```

自连接版本

```sql
SELECT e1.name
FROM employee AS e1 INNER JOIN employee AS e2
ON e1.department = e2.department
      AND e2.name = "Jim";
```

### 外连接

外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。

检索所有顾客的订单信息，包括还没有订单信息的顾客。

```sql
SELECT Customers.cust_id, Customer.cust_name, Orders.order_id
FROM Customers LEFT OUTER JOIN Orders
ON Customers.cust_id = Orders.cust_id;
```

# 高可用/性能

## 读写分离

### 什么是读写分离？

见名思意，根据读写分离的名字，我们就可以知道：**读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。** 这样的话，就能够小幅提升写性能，大幅提升读性能。

我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。

![读写分离示意图](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png)

一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。

### 读写分离会带来什么问题？如何解决？

读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 **主从同步延迟** 。

主从同步延迟问题的解决，没有特别好的一种方案（可能是我太菜了，欢迎评论区补充）。你可以根据自己的业务场景，参考一下下面几种解决办法。

**1.强制将读请求路由到主库处理。**

既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。

比如 `Sharding-JDBC` 就是采用的这种方案。通过使用 Sharding-JDBC 的 `HintManager` 分片键值管理器，我们可以强制使用主库。

```java
HintManager hintManager = HintManager.getInstance();
hintManager.setMasterRouteOnly();
// 继续JDBC操作
```

对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。

**2.延迟读取。**

还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。

不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。

### 如何实现读写分离？

不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：

1. 部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。
2. 保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的**主从复制**。
3. 系统将写请求交给主数据库处理，读请求交给从数据库处理。

落实到项目本身的话，常用的方式有两种：

**1.代理方式**

![代理方式实现读写分离](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation-proxy.png)

我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。

提供类似功能的中间件有 **MySQL Router**（官方）、**Atlas**（基于 MySQL Proxy）、**Maxscale**、**MyCat**。

**2.组件方式**

在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。

这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 `sharding-jdbc` ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。

## 分库分表

> 阿里云，唯品会，美团，邮储

随着数据量的增长，单个数据库存储和处理数据的能力会逐渐达到瓶颈。为了解决这个问题，可以将数据分散到多个数据库或表中，这就是数据库的分库分表。

### 什么是分库？

**垂直分库** 就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。

举个例子：说你将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。

![垂直分库](data:image/png;base64,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)

**水平分库** 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。

举个例子：订单表数据量太大，你对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库。

![水平分库](https://javaguide.cn/assets/horizontal-slicing-database.53fbc43a.png)

### 什么是分表？

**垂直分表**：将一个表的列按照业务逻辑分拆到不同的表中，通常是将经常使用的列放在一个表中，而不常用的列放在另一个表中。垂直分表的优点是方便维护和优化，缺点是需要进行关联查询，可能会影响查询效率。

**水平分表**：将一个表的数据按照一定的规则分散到多个表或多个数据库中，通常是将数据按照某个条件（如时间、地域等）进行划分。水平分表的优点是可以解决单一表数据量过大的问题，提高查询效率，缺点是需要在查询时合并结果集，可能会影响性能。

![分表](https://javaguide.cn/assets/two-forms-of-sub-table.3475ce44.png)

### 什么情况下需要分库分表？

遇到下面几种场景可以考虑分库分表：

- 单表的数据达到千万级别以上，数据库读写速度比较缓慢。
- 数据库中的数据占用的空间越来越大，备份时间越来越长。
- 应用的并发量太大。

### 常见的分片算法有哪些？

分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。

- **哈希分片** ：求指定 key（比如 id） 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。
- **范围分片** ：按照特性的范围区间（比如时间区间、ID区间）来分配数据，比如 将 `id` 为 `1~299999` 的记录分到第一个库， `300000~599999` 的分到第二个库。范围分片适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。
- **地理位置分片** ：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。
- **融合算法** ：灵活组合多种分片算法，比如将哈希分片和范围分片组合。
- ......

### 分库分表会带来什么问题呢？

记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。

引入分库分表之后，会给系统带来什么挑战呢？

- **join 操作** ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。
- **事务问题** ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。
- **分布式 id** ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。
- ......

另外，引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器，这些都属于成本。

------

## MySQL执行一条select语句是如何执行的

> 小米

- 连接器：建立连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

![查询语句执行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

## 主键自增 ID 和 UUID 对比

> 百度，唯品会，普元

1. 自增ID是有序的，而UUID是随机的。前面已经说了，如果主键是有序的，数据库可以具有更好的性能（至少对MySQL而已是如此）
2. 自增ID所需的存储空间比UUID要小
3. 由于自增ID比UUID更加简单，因此生成自增ID的生成速度也比UUID更快
4. 自增ID与数据相关，主键会暴露出去的话，自增ID会显示当前表中的数据规模；而UUID则无此风险
5. 自增ID在不同的数据库中可能重复，在分布式的环境下无法保证唯一。而UUID在分布式环境下也可以保证唯一

## MySQL 主从复制流程及原理

> 滴滴

MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。

1. 主库将数据库中数据的变化写入到 binlog
2. 从库连接主库
3. 从库会创建一个 I/O 线程向主库请求更新的 binlog
4. 主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收
5. 从库的 I/O 线程将接收的 binlog 写入到 relay log 中。
6. 从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。

## MySQL 主从复制的作用？

复制解决的基本问题是让一台服务器的数据与其他服务器保持同步，一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。主库和备库之间可以有多种不同的组合方式。

MySQL 支持两种复制方式：基于行的复制和基于语句的复制，基于语句的复制也称为逻辑复制，从 MySQL 3.23 版本就已存在，基于行的复制方式在 5.1 版本才被加进来。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。因此同一时刻备库的数据可能与主库存在不一致，并且无法包装主备之间的延迟。

MySQL 复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备库，但是老版本不能作为新版本服务器的备库，因为它可能无法解析新版本所用的新特性或语法，另外所使用的二进制文件格式也可能不同。

复制解决的问题：数据分布、负载均衡、备份、高可用性和故障切换、MySQL 升级测试。

## 连接数据库的方式

> 邮储

在 Java 中，连接数据库的方式有多种，以下是其中常用的几种方式：

1. 使用 JDBC 连接数据库

JDBC (Java Database Connectivity) 是 Java 提供的一个用于连接和操作各种关系型数据库的 API。使用 JDBC，我们可以通过驱动程序建立与数据库的连接，并执行各种 SQL 语句。

2. 使用 ORM 框架连接数据库

ORM (Object Relational Mapping) 是一种将对象模型和关系数据库模型映射起来的技术，ORM 框架可以帮助我们更加方便地操作数据库，使得数据库操作更加面向对象化。在 Java 中，比较常用的 ORM 框架包括 Hibernate、MyBatis 等。

3. 使用连接池连接数据库

连接池可以帮助我们更好地管理数据库连接，它通过预先创建一定数量的连接，将连接存放在一个池中，然后在需要连接数据库时，从池中获取一个可用的连接，使用完毕后再将连接归还到池中。连接池可以避免频繁创建和销毁数据库连接，从而提高程序性能和数据库操作的效率。在 Java 中，比较常用的连接池有 DBCP、C3P0、HikariCP 等。

以上是连接数据库的几种常用方式，每种方式都有其优缺点，需要根据实际情况选择合适的方式。
