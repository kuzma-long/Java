# Redis

------

## Redis的应用场景？

> 百度，阿里（企业智能）

Redis是一款高性能的内存数据库，因其快速的读写速度、丰富的数据结构和灵活的配置等特点，在许多应用场景中得到了广泛的应用。以下是一些Redis的典型应用场景：

1. 缓存： Redis可以将经常使用的数据缓存在内存中，从而减少每次查询时对数据库的访问次数，提高应用的响应速度。
2. 数据存储： Redis可以将数据存储在内存中，从而实现快速的读写操作，而不需要像传统数据库那样每次都从磁盘读取数据。
3. 分布式锁： Redis提供了分布式锁的功能，可以保证在分布式环境下数据的一致性和安全性。
4. 消息队列： Redis提供了一些消息队列相关的数据结构，例如List和Pub/Sub，可以用来实现异步处理和消息通信等功能。
5. 计数器： Redis提供了自增和自减操作的支持，可以用来实现计数器等功能。

总的来说，Redis是一个非常灵活、高效的数据存储系统，适合用于许多不同的场景和应用。

------

## 基于redis实现的消息队列，作用，缺点

> 美团

Redis 是一种高性能的内存数据存储系统，通常被用于缓存、会话存储、发布订阅等场景。Redis 也可以用来实现消息队列。

消息队列是一种在不同的系统之间进行异步通信的机制，其中一个系统将消息发送到队列中，另一个系统从队列中获取消息并进行处理。消息队列可以有效地解耦不同系统之间的依赖关系，并提高系统的可伸缩性和可靠性。

使用 Redis 实现消息队列的好处是它可以提供非常高的吞吐量和低延迟。Redis 的内存存储和基于事件的异步模型使得它非常适合处理高并发的消息队列场景。此外，Redis 还提供了一些有用的数据结构和命令，例如 List 和 BLPOP 命令，可以方便地实现消息队列。

然而，使用 Redis 实现的消息队列也有一些缺点。首先，由于 Redis 是内存存储，当系统宕机或者发生故障时，未被处理的消息会丢失。其次，由于 Redis 的内存限制，如果队列中的消息过多，可能会导致 Redis 内存溢出，需要通过一些策略，如限制队列长度或持久化数据等来解决这个问题。最后，由于 Redis 只能在单个节点中运行，如果需要跨多个节点运行 Redis 集群，则需要额外的配置和管理工作。

总的来说，基于 Redis 实现的消息队列是一种高性能、低延迟的解耦机制，但需要注意一些容错和扩展性方面的问题。如果实现得当，Redis 消息队列是一种非常实用的工具。

## Redis 高性能的原因

> 小米，阿里云，美团，蚂蚁

1. 内存存储：Redis是基于内存的数据库，所有数据都存储在内存中，而不是像传统的关系型数据库一样存储在磁盘上。由于内存的读写速度非常快，所以Redis的读写性能非常高。
2. 单线程模型：Redis使用单线程模型来处理所有的请求，因此不需要进行多线程之间的上下文切换，避免了多线程的竞争和锁的开销，提高了系统的并发处理能力。
3. 异步IO：Redis使用了异步IO来进行网络通信，通过非阻塞IO和事件驱动模型实现了高并发，高吞吐量的数据访问。
4. 简单的数据结构：Redis支持的数据结构非常简单，包括字符串、哈希、列表、集合、有序集合等，这些数据结构都非常高效，使得Redis的读写性能更加优秀。
5. 精简的代码：Redis代码非常精简，没有复杂的逻辑和多余的功能，代码量小、结构清晰，易于维护和扩展。

------

## Redis的IO模型

> 小米

## Redis去重方式了解几种，每种方式的优缺点？

> 阿里

HashSet
使用java中的HashSet不能重复的特点去重。优点是容易理解。使用方便。

缺点：占用内存大，性能较低。

Redis去重
使用Redis的set进行去重。优点是速度快（Redis本身速度就很快），而且去重不会占用爬虫服务器的资源，可以处理更大数据量的数据爬取。

缺点：需要准备Redis服务器，增加开发和使用成本。

布隆过滤器（BloomFilter）
使用布隆过滤器也可以实现去重。优点是占用的内存要比使用HashSet要小的多，也适合大量数据的去重操作。

缺点：有误判的可能。没有重复可能会判定重复，但是重复数据一定会判定重复。

## 为什么说 Redis 是单线程的

> 阿里云，腾讯IEG

Redis 之所以被称为单线程的，是因为 Redis 的主要功能在执行时只使用了单个线程。具体来说，Redis 使用一个名为 "文件事件处理器"（File Event Handler）的模块来监听客户端请求，并且在请求到达时，由单个线程来处理请求。

文件事件处理器实际上是一个基于 epoll 或 kqueue 等操作系统特性的网络事件处理器，它可以同时监听多个网络事件，当有事件到达时，文件事件处理器就会将该事件放入队列中。这样，在主循环中，单个线程可以从事件队列中依次取出事件，并执行对应的操作。

因此，Redis 的单线程模型并不意味着 Redis 不能利用多核 CPU 的优势，实际上，Redis 可以利用多线程并发处理多个请求，但每个线程仍然只处理单个请求，并且线程之间通过网络事件队列进行通信。这种方式可以避免多线程之间的上下文切换带来的开销，从而提高 Redis 的并发性能。

## redis线程模型为什么使用单线程

> 拼多多

Redis 使用单线程模型主要是出于两个考虑：

1. 减少锁竞争和线程切换开销

Redis 的主要瓶颈是在 CPU 上，而不是在 IO 上。因此，使用单线程模型可以避免多线程间的锁竞争和线程切换带来的开销，从而提高 CPU 利用率，进而提高 Redis 的性能。

2. 简单、可预测的设计

Redis 的单线程模型可以让其设计变得简单、可预测。Redis 只需要处理单个客户端的请求，不需要考虑多线程之间的同步和协作，这样就可以减少代码复杂度和出错的概率，提高 Redis 的可靠性。

当然，Redis 也并不是真正意义上的单线程。虽然 Redis 会使用单个线程来处理客户端请求，但它也会使用多个线程来处理底层的 IO 操作，如网络 IO 和磁盘 IO 等。这些 IO 线程不会阻塞主线程，而是通过异步 IO 的方式来处理 IO 请求，从而避免了 IO 操作的阻塞。

## 为什么单线程 Redis 性能还这么好

> 阿里云

尽管 Redis 是单线程的，但它的高性能和并发能力并不弱。主要原因如下：

1. 纯内存操作： Redis 所有数据都存储在内存中，内存的读写速度非常快。同时，Redis 采用多路复用技术，可以在同一个线程中处理多个客户端连接，提高了并发能力。
2. 非阻塞 I/O：Redis 使用非阻塞 I/O，它不会为每个客户端连接都创建一个线程，而是采用了一种事件驱动的方式，通过监听文件描述符来处理客户端请求。
3. 单线程避免了线程切换开销：线程切换是非常耗费 CPU 的操作。如果使用多线程的方式来实现 Redis，那么在高并发的情况下，线程切换的开销会很大。因此，采用单线程的方式可以避免这种开销，提高性能。
4. 高效的数据结构和算法： Redis 采用了一些高效的数据结构和算法，例如跳表和快速列表等，这些数据结构和算法的时间复杂度比较低，能够快速地进行数据操作，提高了 Redis 的性能。

综上所述，尽管 Redis 是单线程的，但它采用了一些高效的技术和算法，能够快速地进行数据操作，同时能够处理大量的并发请求，因此性能表现出色。

## 什么是布隆过滤器？

> 阿里

首先，我们需要了解布隆过滤器的概念。

布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。

![布隆过滤器示意图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-bit数组.png)

位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。

总结：**一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。**

## 布隆过滤器的原理介绍

> 阿里

**当一个元素加入布隆过滤器中的时候，会进行如下操作：**

1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

**当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：**

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

举个简单的例子：

![布隆过滤器hash计算](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-hash运算.png)

如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。

如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

**不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。**

综上，我们可以得出：**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

## 布隆过滤器使用场景

> 阿里

1. 判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。
2. 去重：比如爬给定网址的时候对已经爬取过的 URL 去重。

# 数据结构

## Redis 常用的数据结构及底层实现

> 蔚来，比亚迪，zoom，小米，字节，阿里云，拼多多，用友，美团

1. String（字符串）：String是Redis最简单的数据结构，底层实现使用的是简单动态字符串（SDS）。SDS的特点是：可以高效地完成字符串的追加、修改、删除等操作，避免了C语言中的缓冲区溢出等问题。
2. Hash（哈希表）：Hash实现了键值对的存储和查找，底层实现使用的是哈希表。哈希表的特点是：查询、插入、删除操作的时间复杂度均为O(1)。
3. List（列表）：List是一个双向链表结构，底层实现使用的是压缩列表和双向链表。当存储数据较少时，底层实现使用的是压缩列表；当存储数据较多时，底层实现使用的是双向链表。
4. Set（集合）：Set是一个无序的字符串集合，底层实现使用的是哈希表或者跳跃表。当集合中元素较少时，使用哈希表实现，当元素较多时，使用跳跃表实现。
5. Sorted Set（有序集合）：Sorted Set是一个有序的字符串集合，底层实现使用的是跳跃表和哈希表。跳跃表的作用是对有序集合的元素进行排序，而哈希表的作用是实现元素到分值的映射。
6. Bitmap（位图）：Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。
7. HyperLogLog：用于估计一个集合中独立元素的数量，HyperLogLog类型常用于统计在线用户数等。
8. Geospatial index（地理空间索引，简称 GEO）： 主要用于存储地理位置信息，基于 Sorted Set 实现。通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。

## 简单动态字符串（SDS）

简单动态字符串（简称SDS）是一种用C语言实现的字符串数据结构，它可以自动扩展存储空间以适应字符串长度的变化，同时还支持常数时间内获取字符串长度和O(1)时间复杂度的字符串连接操作。

SDS的设计灵感来源于C语言中的字符数组，但相比字符数组，它具有以下优点：

1. 自动扩容：SDS可以自动分配更多的存储空间来适应字符串长度的变化，避免了手动管理内存的麻烦。
2. 二进制安全：SDS可以存储任意二进制数据，不会出现类似于C语言中以'\0'结尾的字符串的问题。
3. 高效操作：SDS支持常数时间内获取字符串长度和O(1)时间复杂度的字符串连接操作，这些操作在字符数组中需要花费O(N)的时间复杂度。

总之，SDS是一个高效、灵活、安全的字符串数据结构，因此在一些需要高效操作字符串的应用中得到广泛应用。

## zset底层实现原理

> 滴滴，字节，蔚来

zset是Redis提供的一个有序集合数据类型，它类似于集合，但每个成员都有一个相关的分值，根据分值可以对成员进行排序。zset的底层实现主要有ziplist和跳表+哈希表两种方式。

zset-max-ziplist-entries 128：zset采用压缩列表时，元素个数最大值。默认值为128。
zset-max-ziplist-value 64：zset采用压缩列表时，每个元素的字符串长度最大值。默认值为64。

zset插入第一个元素时，会判断下面两种条件，zset-max-ziplist-entries的值是否等于0，zset-max-ziplist-value是否小于要插入元素的字符串长度，满足任一条件Redis就会采用跳跃表作为底层实现，否则采用压缩列表作为底层实现方式。

一般情况下，不会将zset-max-ziplist-entries配置成0，元素的字符串长度也不会太长，所以在创建有序集合时，默认使用压缩列表的底层实现。zset新插入元素时，会判断以下两种条件：zset中元素个数大于zset_max_ziplist_entries；插入元素的字符串长度大于zset_max_ziplist_value。当满足任一条件时，Redis便会将zset的底层实现由压缩列表转为跳跃表+哈希表。

ziplist本身没有排序功能，而且没有键值对的概念，因此需要由zset通过编码实现：

- ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后

- score越小越接近队首，score越大越接近队尾，按照score值升序排列

哈希表通过一个键值对映射函数将键映射为哈希表中的一个位置。在zset中，哈希表中的每个键都是zset的成员，对应的值是成员的分数。通过哈希表，我们可以以O(1)的时间复杂度找到任何一个成员的分数。

跳跃表是一种数据结构，具有高效的查找和插入操作。在zset中，跳跃表用来保存成员按分数从小到大的有序序列。通过跳跃表，我们可以以O(log n)的时间复杂度找到任何一个成员在有序序列中的位置。

## Redis渐进式rehash原理？

> 滴滴

Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。

Dict在每次新增键值对时都会检查**负载因子**（LoadFactor = used/size） ，满足以下两种情况时会触发**哈希表扩容**：

- 哈希表的 LoadFactor >= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；

- 哈希表的 LoadFactor > 5 ；

Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor < 0.1 时，会做哈希表收缩

不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为**rehash**。

![image-20230218163432912](E:\Typora\image-20230218163432912.png)

## 跳表怎么实现的，查找的过程。

> 字节，拼多多

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf843a9030dd442b8bed1dcb41ff1079~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

跳表（Skip List）是一种基于有序链表的数据结构，它使用了一些“跳跃式”的思想，可以在时间复杂度为 O(log n) 的情况下，实现元素的快速查找、插入和删除操作。跳表的底层实现可以使用多层链表来实现，每一层链表都是原链表的一个子集，且每一层链表中的元素都比下一层链表中的元素少。

跳表的查找过程如下：

1. 从跳表的最高层开始，从左到右遍历该层链表，如果当前节点的值小于目标值，就向右移动，继续查找；如果当前节点的值大于目标值，就向下移动一层，继续查找。
2. 重复上述步骤，直到找到目标节点或者到达跳表的最后一层。
3. 如果找到目标节点，则返回该节点；如果没有找到目标节点，则返回 NULL。

跳表的插入和删除操作也类似，都需要从最高层开始，按照上述的查找过程，找到要插入或删除的节点所在的位置，然后进行相应的操作即可。

------

# 持久化

## Redis持久化机制

> 比亚迪，英雄游戏，阿里云，万得，字节，百度，美团

Redis是一个基于内存的高性能key-value存储系统。为了避免Redis进程宕机或异常情况下数据丢失，Redis提供了两种持久化策略：AOF和RDB。

### AOF

AOF（Append Only File）是将Redis执行的所有修改命令追加到文件中的持久化方式。AOF持久化的实现是通过写命令日志的方式，将Redis执行过的写命令追加到一个日志文件中。Redis重启时，根据日志文件中的命令顺序，重新执行一次AOF文件中的命令，使得Redis恢复到宕机前的状态。

优点：

- 可以减少数据丢失风险，数据持久化的效果较好；
- 适用于记录所有写操作场景，安全性高；
- 可以避免由于突然断电或其他异常情况导致的数据损失。

缺点：

- AOF文件比较大，需要定期压缩和清理，需要较多的磁盘空间；
- 在AOF持久化过程中，性能会有所下降，由于是将所有写操作记录到AOF文件，会导致持久化时间变长，对Redis性能有一定影响。

### RDB

RDB（Redis Database Backup）是在指定时间间隔内，对Redis数据进行备份，将Redis在某个时间点上的全部数据快照写入磁盘文件中，保存为一个RDB文件。在需要恢复数据时，Redis可以读取RDB文件，将数据恢复到内存中。

优点：

- RDB文件体积比较小，相对AOF文件来说，磁盘占用率较低；
- RDB文件是以二进制格式保存的，对存储和读取速度较快，对Redis性能影响小。

缺点：

- RDB文件只能恢复到指定时间点上的数据，如果最近一次备份时间过久，会导致大量数据丢失；
- RDB方式备份的数据，无法实时备份，如果发生数据变动，备份的数据就不是最新的。

综上所述，AOF持久化更加适合需要数据高可靠性、可以承受少量性能损失的场景，而RDB持久化更适合对存储空间敏感的场景。在实际生产环境中，也可以同时使用AOF和RDB来保证数据的高可用性和灵活性。

------

## AOF重写

> 字节

AOF（Append Only File）重写是 Redis 中的一项重要操作，用于优化 AOF 文件的大小和性能。由于 AOF 文件会不断地增长，会导致 Redis 读取 AOF 文件时的性能下降。因此，AOF 重写就是在不丢失数据的情况下，重新生成一个更小的 AOF 文件。

AOF 重写的基本思路是：通过遍历当前 Redis 数据库中所有的键值对，来生成一份新的 AOF 文件，这个过程中会丢弃掉一些无用的操作，例如被 DEL 命令删除的键。生成新的 AOF 文件后，会替换掉旧的 AOF 文件，并开始使用新的 AOF 文件来记录操作日志。

## bgsave 的原理？

> 英雄游戏

① 执行 bgsave 命令，Redis 父进程判断当前是否存在正在执行的子进程，如 RDB/AOF 子进程，如果存在 bgsave 命令直接返回。

② 父进程执行 fork 操作创建子进程，fork 操作过程中父进程会阻塞。

③ 父进程 fork 完成后，bgsave 命令返回并不再阻塞父进程，可以继续响应其他命令。

④ 子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。

⑤ 进程发送信号给父进程表示完成，父进程更新统计信息。

# 缓存

## 缓存雪崩/穿透/击穿

> 小米，阿里云，万得，字节，百度，蚂蚁

### 缓存雪崩

**缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。**

举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。

#### 有哪些解决办法？

1. 增加缓存过期时间的随机性：可以在缓存过期时间上增加一定的随机时间，使得缓存不会在同一时间全部失效，从而减少缓存雪崩的概率。
2. 使用分布式锁：使用分布式锁可以保证只有一个线程去更新缓存，其他线程等待，这样可以避免大量线程同时去查询数据库的情况，从而减少对数据库的冲击。
3. 使用多级缓存：可以将缓存分为多级，如本地缓存、分布式缓存等，不同级别的缓存过期时间不同，可以使缓存过期的时间错开，减少缓存雪崩的概率。
4. 缓存预热：在系统启动时，可以提前加载一些常用的数据到缓存中，这样可以减少在业务高峰期时缓存失效导致的数据库压力。
5. 数据库水平扩展：如果数据库压力过大，可以考虑对数据库进行水平扩展，将数据分散到多个数据库中，从而减少单一数据库的压力。
6. 限流措施：在系统高峰期，可以通过限流措施来控制请求的流量，避免大量请求落到后端服务上，从而保证系统的稳定性。

### 缓存穿透

缓存穿透说简单点就是大量请求的 key 是不合理的，**根本不存在于缓存中，也不存在于数据库中** 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。

#### 有哪些解决办法？

最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。

**1）缓存无效 key**

如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： `SET key value EX 10086` 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。

**2）布隆过滤器**

具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： **布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

*为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！*

我们先来看一下，**当一个元素加入布隆过滤器中的时候，会进行哪些操作：**

1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

我们再来看一下，**当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：**

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

然后，一定会出现这样一种情况：**不同的字符串可能哈希出来的位置相同。** （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）

------

### 缓存击穿

缓存击穿中，请求的 key 对应的是 **热点数据** ，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）** 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。

#### 有哪些解决办法？

- 设置热点数据永不过期或者过期时间比较长。
- 针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。
- 请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。

------

## redis和MySQL数据一致性问题

> 美团，字节TikTok，腾讯IEG，zoom，阿里（企业智能），阿里云，蚂蚁

- **实时一致性方案**：采用“先写 MySQL，再删除 Redis”的策略，这种情况虽然也会存在两者不一致，但是需要满足的条件有点苛刻，**所以是满足实时性条件下，能尽量满足一致性的最优解。**
- **最终一致性方案**：采用“先写 MySQL，通过 Binlog，异步更新 Redis”，可以通过 Binlog，结合消息队列异步更新 Redis，**是最终一致性的最优解。**

### 先写 MySQL，再删除 Redis

![img](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/redis-shuju-yizhixing-1f0e26a8-49c3-469e-a193-08f9766943aa.png)

对于上面这种情况，对于第一次查询，请求 B 查询的数据是 10，但是 MySQL 的数据是 11，**只存在这一次不一致的情况，对于不是强一致性要求的业务，可以容忍。**（那什么情况下不能容忍呢，比如秒杀业务、库存服务等。）

当请求 B 进行第二次查询时，因为没有命中 Redis，会重新查一次 DB，然后再回写到 Redis。

![img](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/redis-shuju-yizhixing-268696d3-a7e9-4762-9fe6-283859d5b0ba.png)

这里需要满足 2 个条件：

- 缓存刚好自动失效；
- 请求 B 从数据库查出 10，回写缓存的耗时，比请求 A 写数据库，并且删除缓存的还长。

对于第二个条件，我们都知道更新 DB 肯定比查询耗时要长，所以出现这个情况的概率很小，同时满足上述条件的情况更小。

### 先写 MySQL，通过 Binlog，异步更新 Redis

这种方案，主要是监听 MySQL 的 Binlog，然后通过异步的方式，将数据更新到 Redis，这种方案有个前提，查询的请求，不会回写 Redis。

![img](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/redis-shuju-yizhixing-0da55874-8cf7-4c5a-995b-a0e6611bfac2.png)

这个方案，会保证 MySQL 和 Redis 的最终一致性，但是如果中途请求 B 需要查询数据，如果缓存无数据，就直接查 DB；如果缓存有数据，查询的数据也会存在不一致的情况。

**所以这个方案，是实现最终一致性的终极解决方案，但是不能保证实时性。**

## Redis缓存淘汰策略？

> 腾讯，阿里云，字节，百度，美团

1. LRU（Least Recently Used）：最近最少使用。即如果一个键在最近一段时间内没有被访问过，那么就可以被淘汰。这种策略适用于热点数据的缓存，因为热点数据通常会被频繁访问。
2. LFU（Least Frequently Used）：最不经常使用。即如果一个键在一段时间内被访问的次数很少，那么就可以被淘汰。这种策略适用于非热点数据的缓存，因为非热点数据通常不会被频繁访问。
3. Random：随机淘汰。即随机选择一个键进行淘汰。这种策略适用于缓存数据访问频率比较均匀的情况。
4. TTL（Time To Live）：设置过期时间。即为每个键设置一个过期时间，在到达过期时间时自动淘汰。这种策略适用于缓存数据过期比较频繁的情况。
5. LRU-K：LRU-K算法是LRU算法的改进版，它不仅考虑最近使用时间，还考虑了过去K次使用的时间，即在一个时间窗口内，最近K次使用时间较长的键会被保留，其它的则会被淘汰。这种策略适用于缓存数据访问具有周期性的情况。

## Redis的key过期删除策略

> 万得，阿里云，美团

当 Redis 存储的 key 被设置了过期时间，当 key 的过期时间到期后，会触发 Redis 的过期删除策略。Redis 的过期删除策略采用惰性删除和定期删除相结合的方式，具体过程如下：

- 惰性删除：当 Redis 客户端尝试访问一个已经过期的 key 时，Redis 会立即将该 key 删除。
- 定期删除：Redis 会定期扫描过期的 key，并将过期的 key 删除。在定期删除过程中，Redis 会使用惰性删除策略删除 key。

------

# 分布式锁

> 小米，字节，亚信

## Redis实现分布式锁

> 小米，德胧集团，华讯网络，美团，阿里云，万得，用友，阿里（企业智能）

分布式锁通常用于在分布式系统中控制并发访问共享资源。当多个进程或线程同时需要访问共享资源时，分布式锁可以保证同一时间只有一个进程或线程能够访问共享资源，以避免竞态条件和数据不一致等问题。

Redis是一种常用的分布式缓存和键值存储系统，它提供了一种简单而可靠的实现分布式锁的方法。

- 我们可以将锁作为一个Redis的key，然后通过`SETNX`+expire命令去获取锁，并设置过期时间（防止锁因为某些原因没有被释放）。
- `SETNX` 即 **SET** if **N**ot e**X**ists ，如果该key不存在，`SETNX`命令会成功设置该key的值；否则，表示该锁已被其他进程或线程持有，无法获得锁。释放锁的话，直接通过 `DEL` 命令删除对应的 key 即可。
- 这里setnx和expire两个命令不是原子执行的，可能会发生过期时间设置失败的情况，所以采用redis的set指令的扩展参数set nx ex来设置更加方便。
- 需要注意的是，由于网络延迟等因素的存在，可能会出现锁被误删除的情况，这时候可以给锁设置一个当前线程ID的值，并在释放锁时检查该值是否与当前线程一致，从而避免误删其他进程或线程持有的锁。

## redis分布式锁可能出现的问题和解决方案

> 蚂蚁

使用Redis实现分布式锁时，可能会出现以下问题：

1. 竞争条件：当多个客户端同时请求获取锁时，可能会出现竞争条件，导致多个客户端都获取到了锁。这可能会导致数据的混乱或者并发访问问题。

解决方案：使用Redis的setnx命令来实现互斥性，只有一个客户端能够成功获取锁。

2. 死锁问题：如果一个客户端获取了锁后，由于某些原因没有释放锁，那么其他客户端就无法获取锁，可能会导致死锁问题。

解决方案：为锁设置一个过期时间，在获取锁时设置锁的过期时间，在释放锁时检查锁是否过期，如果过期则释放锁。

3. 容错问题：如果持有锁的Redis实例崩溃了，那么其他客户端无法获取锁，可能会导致系统不可用。

解决方案：使用Redis的RedLock算法，将锁在多个Redis实例之间进行复制，当一个Redis实例崩溃时，其他Redis实例仍然可以保持锁的可用性。

4. 性能问题：当多个客户端同时请求获取锁时，Redis可能会出现性能瓶颈，导致系统响应变慢。

解决方案：使用Redis的lua脚本实现原子性操作，减少客户端与Redis之间的网络通信，提高系统的性能。

## Redis分布式锁死锁问题如何解决

> 阿里飞猪

Redis分布式锁是通过使用SETNX命令实现的。具体实现方式是，使用SETNX命令尝试获取锁，如果返回值为1，则表示获取锁成功；如果返回值为0，则表示锁已被其他客户端持有，获取锁失败。

然而，分布式锁可能会出现死锁问题，即某个客户端获取到锁后，因为某种原因未能及时释放锁，导致其他客户端无法获取锁，进而导致整个系统处于不可用状态。

为了避免Redis分布式锁的死锁问题，可以使用以下两种方法：

1. 设置过期时间：在使用SETNX命令获取锁成功后，设置一个过期时间，如果在过期时间内没有释放锁，则自动释放锁。在释放锁的时候，需要使用Lua脚本来保证原子性操作，避免在删除锁的时候误删其他客户端的锁。
2. 使用红锁算法：红锁算法是在多个Redis实例之间实现分布式锁的一种算法。它需要在多个Redis实例上获取锁，在获取锁的过程中，需要获取锁的实例数量达到一定的要求才能获取锁。这样可以避免因单个Redis实例故障或网络延迟导致的死锁问题。

无论使用哪种方法，都需要根据具体业务场景和系统环境选择最合适的解决方案。在实际应用中，还需要考虑网络延迟、Redis实例故障等因素对分布式锁的影响，以及如何在不同的情况下选择最佳的解决方案。

## 如何实现可重入锁？

> 英雄游戏，字节

所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 `synchronized` 和 `ReentrantLock` 都属于可重入锁。

**不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。**

可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。

实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 **Redisson** ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。

------

## 分布式锁还有哪些实现方案

> 字节

### 基于数据库实现分布式锁

实现原理：把数据库select检索出的数据用for update加锁，其他事务不能修改这条数据，也不能再给这条数据加锁，解锁使用comit提交当前事务。

### 基于Zookeeper实现分布式锁

实现原理：利用Zookeeper创建瞬时节点有序的特性，在多线程并发创建瞬时节点，会得到有序的节点序列，我们规定序号最小的线程获得锁。其他线程利用观察器监听自己序号前一个序号的存在状态，前一个线程执行完成，删除自己序号的节点，下一个序号的线程得到通知，执行自己的任务。

### 基于Curator实现分布式锁

Curator是Zookeeper客户端的升级版，已经实现了分布式锁的功能，直接使用即可。

### 基于Redisson实现分布式锁

Redisson是Redis客户端的升级版，已经实现了分布式锁的功能，直接使用即可。

### 基于RedLock实现分布式锁

> 字节TikTok

假设有两个服务A、B都希望获得锁，有一个包含了5个redis master的Redis Cluster，执行过程大致如下:

1. 获取当前Unix时间，以毫秒为单位。
2. 依次尝试从5个实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。
3. 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。
4. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。
5. 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。

------

# Redis主从复制

> zoom，小米

## 主从复制概述

> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。

**主从复制的作用**主要包括：

- **数据冗余**：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
- **故障恢复**：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
- **负载均衡**：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
- **高可用基石**：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

主从库之间采用的是**读写分离**的方式。

- 读操作：主库、从库都可以接收；
- 写操作：首先到主库执行，然后，主库将写操作同步给从库。

![img](https://pdai.tech/images/db/redis/db-redis-copy-1.png)

------

# 集群

> 美团，阿里

## Redis 集群了解吗？

前面说到了主从存在高可用和分布式的问题，哨兵解决了高可用的问题，而集群就是终极方案，一举解决高可用和分布式问题。 ![Redis 集群示意图](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-5cbc6009-251e-4d5b-8f22-8d543938eccb.png)

1. **数据分区：** 数据分区 *(或称数据分片)* 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制，**存储容量大大增加**；**另一方面** 每个主节点都可以对外提供读服务和写服务，**大大提高了集群的响应能力**。
2. **高可用：** 集群支持主从复制和主节点的 **自动故障转移** *（与哨兵类似）*，当任一节点发生故障时，集群仍然可以对外提供服务。

## 集群中数据如何分区？

分布式的存储中，要把数据集按照分区规则映射到多个节点，常见的数据分区规则三种： ![分布式数据分区](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-ceb49e41-dfd7-4d1e-91f9-c299437227d2.png)

### 方案一：节点取余分区

节点取余分区，非常好理解，使用特定的数据，比如Redis的键，或者用户ID之类，对响应的hash值取余：hash（key）%N，来确定数据映射到哪一个节点上。

不过该方案最大的问题是，当节点数量变化时，如扩容或收缩节点，数据节点映射关 系需要重新计算，会导致数据的重新迁移。

![节点取余分区](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-8b1fcaec-37e6-420a-9ca2-03615232af17.png)节点取余分区

### 方案二：一致性哈希分区

将整个 Hash 值空间组织成一个虚拟的圆环，然后将缓存节点的 IP 地址或者主机名做 Hash 取值后，放置在这个圆环上。当我们需要确定某一个 Key 需 要存取到哪个节点上的时候，先对这个 Key 做同样的 Hash 取值，确定在环上的位置，然后按照顺时针方向在环上“行走”，遇到的第一个缓存节点就是要访问的节点。

比如说下面 这张图里面，Key 1 和 Key 2 会落入到 Node 1 中，Key 3、Key 4 会落入到 Node 2 中，Key 5 落入到 Node 3 中，Key 6 落入到 Node 4 中。 ![一致性哈希分区](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-89bd1c1c-251c-4f53-bba3-fe945b2ae9e2.png)

这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中 相邻的节点，对其他节点无影响。

但它还是存在问题：

- 缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大
- 当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，会对后面这个节点造成力。

### 方案三：虚拟槽分区

这个方案 一致性哈希分区的基础上，引入了 **虚拟节点** 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 **槽（slot）**。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。 ![虚拟槽分配](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-e0ed9d62-3406-40db-8b01-c931f1020612.png)

在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 `4` 个实际节点，假设为其分配 `16` 个槽(0-15)；

- 槽 0-3 位于 node1；4-7 位于 node2；以此类推....

如果此时删除 `node2`，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 `node1`，槽 6 分配给 `node3`，槽 7 分配给 `node4`，数据在其他节点的分布仍然较为均衡。

## 能说说Redis集群的原理吗？

Redis集群通过数据分区来实现数据的分布式存储，通过自动故障转移实现高可用。

### 集群创建

数据分区是在集群创建的时候完成的。 ![集群创建](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-046a512c-baab-4e3a-9409-2af58088cceb.png)

**设置节点** Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。 ![节点和握手](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-e6064ba6-fd6f-4270-92f9-68c0bb98fd4b.png)**节点握手** 节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信， 达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命 令：cluster meet{ip}{port}。完成节点握手之后，一个个的Redis节点就组成了一个多节点的集群。

**分配槽（slot）** Redis集群把所有的数据映射到16384个槽中。每个节点对应若干个槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots命令为节点分配槽。

![分配槽](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-15341792-e7a6-428c-a109-22827e02be5f.png)分配槽

### 故障转移

Redis集群的故障转移和哨兵的故障转移类似，但是Redis集群中所有的节点都要承担状态维护的任务。

**故障发现** Redis集群内节点通过ping/pong消息实现节点通信，集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong 消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节 点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态。 ![主观下线](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-84a2a89e-f9ea-4681-b748-1a4f1dee172b.png) 当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。当 半数以上持有槽的主节点都标记某个节点是主观下线时。触发客观下线流程。 ![主观下线和客观下线](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b61a6109-7aea-45ab-a53c-267eebb9180a.png)

**故障恢复**

故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它 的从节点中选出一个替换它，从而保证集群的高可用。

![故障恢复流程](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-0e5a49b3-cb5a-4aef-a81f-fce50a012a39.png)故障恢复流程

1. 资格检查 每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障 的主节点。
2. 准备选举时间 当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该 时间后才能执行后续流程。
3. 发起选举 当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程。
4. 选举投票 持有槽的主节点处理故障选举消息。投票过程其实是一个领导者选举的过程，如集群内有N个持有槽的主节 点代表有N张选票。由于在每个配置纪元内持有槽的主节点只能投票给一个 从节点，因此只能有一个从节点获得N/2+1的选票，保证能够找出唯一的从节点。 ![选举投票](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-d0e16ea3-6683-43f4-82a3-80478703ae06.png)
5. 替换主节点 当从节点收集到足够的选票之后，触发替换主节点操作。

> **部署Redis集群至少需要几个物理节点？**

在投票选举的环节，故障主节点也算在投票数内，假设集群内节点规模是3主3从，其中有2 个主节点部署在一台机器上，当这台机器宕机时，由于从节点无法收集到 3/2+1个主节点选票将导致故障转移失败。这个问题也适用于故障发现环节。因此部署集群时所有主节点最少需要部署在3台物理机上才能避免单点问题。

## 说说集群的伸缩？

Redis集群提供了灵活的节点扩容和收缩方案，可以在不影响集群对外服务的情况下，为集群添加节点进行扩容也可以下线部分节点进行缩容。 ![集群的伸缩](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-dd3e9494-eddb-4861-85f7-2646018d93f6.png)其实，集群扩容和缩容的关键点，就在于槽和节点的对应关系，扩容和缩容就是将一部分`槽`和`数据`迁移给新节点。

例如下面一个集群，每个节点对应若干个槽，每个槽对应一定的数据，如果希望加入1个节点希望实现集群扩容时，需要通过相关命令把一部分槽和内容迁移给新节点。

# 其他

## redis bigkey问题

> 蔚来，德胧，美团

Redis中的BigKey问题是指在Redis中，存储的某个key的value非常大，超过Redis的最大内存限制或Redis单个操作的最大值限制，从而导致Redis的性能和稳定性下降。

通常情况下，Redis的性能和吞吐量都是很高的，但当Redis中存在大的key时，会影响到Redis的性能，主要表现在以下几个方面：

1. 内存占用：大key占用过多的内存，导致Redis内存不足，影响Redis性能。
2. 网络带宽：大key的读写需要消耗更多的网络带宽，导致Redis网络延迟增加。
3. 持久化性能：在AOF和RDB持久化模式下，写入大key会导致持久化操作变慢。

因此，需要尽量避免出现BigKey问题，常见的解决方法包括：

1. 优化Redis的内存配置：通过配置maxmemory和maxmemory-policy等参数，限制Redis的内存占用和淘汰策略。
2. 分布式存储：通过将大key分散到多个Redis实例中，减小单个Redis实例的压力，提高Redis集群的整体性能。
3. 对于大对象使用压缩算法进行压缩存储，比如使用zstd进行压缩。

## lru如何实现，redis中是如何实现的？

> 字节

LRU（Least Recently Used）是一种常用的缓存淘汰策略，即淘汰最近最少使用的数据，保留经常使用的数据。它的核心思想是根据数据的访问时间来决定淘汰哪些数据。

在实现 LRU 策略时，通常需要维护一个访问记录，以便在缓存空间满时能够快速找到最近最少使用的数据进行淘汰。常见的实现方式有：

1. 使用双向链表 + 哈希表：链表按访问时间排序，链表头为最近访问的元素，链表尾为最久未被访问的元素，哈希表用于存储节点的地址，以支持 O(1) 的访问和修改。
2. 使用 TreeMap：通过自定义排序方式，将访问时间作为键，元素作为值，实现基于访问时间的排序。

在 Redis 中，也实现了 LRU 策略，用于在缓存满时淘汰键值对。Redis 中 LRU 策略的实现基于上述第一种方式，即使用双向链表 + 哈希表来维护访问记录。具体来说，Redis 的 LRU 策略包括以下步骤：

1. 新增键值对时，将节点插入到链表头部，表示最近被访问。
2. 当缓存空间满时，从链表尾部开始淘汰节点，直到缓存大小满足要求。
3. 当某个键值对被访问时，将其节点移动到链表头部。

需要注意的是，Redis 的 LRU 策略是基于内存的，即当 Redis 内存不足时才会触发缓存淘汰。如果需要持久化数据，可以结合 AOF 或 RDB 持久化策略来使用。

## Redis哨兵模式

> 阿里云

Redis哨兵模式是Redis高可用性的一种实现方式，通过引入哨兵进程，对Redis节点进行监控和自动故障恢复。当主节点发生宕机或不可用时，哨兵会自动选举从节点中的一个作为新的主节点，同时通知应用程序修改主节点地址，从而实现Redis高可用性的切换。

哨兵模式主要有以下几个角色：

1. Redis主节点：负责处理应用程序的读写请求。
2. Redis从节点：复制主节点的数据，以备主节点不可用时接替成为新的主节点。
3. Redis哨兵：监控Redis主节点和从节点的状态，并在主节点不可用时选举新的主节点。
4. Redis客户端：向Redis主节点发送读写请求。

在哨兵模式下，哨兵进程需要完成以下任务：

1. 监控主节点和从节点的状态，包括节点是否存活、节点复制状态、节点复制偏移量等。
2. 当主节点不可用时，从节点中选举新的主节点，并将新主节点的地址通知给客户端。
3. 将故障转移的过程记录到Sentinel状态文件中，以便重启Sentinel进程时恢复上次的状态。
4. 执行自动故障恢复，将下线的主节点恢复为从节点，并对其进行重新复制。

哨兵模式是一种比较简单的高可用性实现方式，但是其存在一些缺点，如故障转移过程中可能会出现数据丢失、无法进行跨数据中心部署等问题。因此，在一些高要求的应用场景中，通常会选择Redis集群或者其他高可用性方案。

## Mysql 和 Redis 区别

> 阿里云

MySQL和Redis都是常见的数据库，二者有以下区别：

1. 数据类型不同：MySQL支持关系型数据，Redis支持键值对存储。
2. 存储方式不同：MySQL采用磁盘存储，Redis采用内存存储。
3. 读写速度不同：Redis基于内存操作，读写速度快；而MySQL基于磁盘操作，读写速度相对较慢。
4. 数据库大小不同：MySQL能够处理大型数据库，Redis适合处理小型数据库。
5. 数据一致性不同：MySQL保证数据的一致性和完整性，Redis不保证数据的一致性和完整性。
6. 数据库功能不同：MySQL支持复杂的SQL查询，Redis提供了一些高级的数据结构和缓存功能。
7. 可扩展性不同：MySQL支持水平和垂直扩展，Redis支持水平扩展。

需要根据具体应用场景选择合适的数据库。如果需要高速读写和缓存功能，可以选择Redis；如果需要进行复杂的查询和处理大型数据集，可以选择MySQL。

## 如果Redis启动协程更**新数据到数据库失败**了怎么处理

> 美团

在使用Redis进行高并发时，协程更新数据到数据库失败是一个比较常见的问题。一般情况下，我们可以采用以下方式来处理：

1. 异常重试：在协程更新数据到数据库失败时，可以对操作进行重试。重试次数可以根据实际情况进行设定，如果重试次数过多或重试时间过长，则可能会影响到系统性能。
2. 异步处理：可以将协程更新数据到数据库的操作异步化处理，不直接进行阻塞等待。一种常见的方式是使用消息队列，将数据更新操作放入消息队列中，然后异步处理。
3. 数据回滚：在协程更新数据到数据库失败时，可以进行数据回滚操作，将Redis中的数据恢复到更新前的状态。这种方式需要保证数据的一致性和可靠性，同时需要考虑性能问题。

需要注意的是，在使用Redis进行高并发时，要充分考虑各种异常情况的处理，以保证系统的可靠性和性能。

## Redis实现分布式ID

> 蔚来
