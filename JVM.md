# 内存区域划分

## 简单介绍一下JVM

> 携程

JVM（Java虚拟机）是Java语言的运行环境，它可以执行Java字节码，并提供了一些基础的类库和运行时环境。JVM作为Java语言的核心，扮演着重要的角色。

JVM主要有三个部分组成：类加载器、执行引擎和内存管理系统。其中，类加载器负责将字节码文件加载到内存中；执行引擎负责解释执行字节码文件，并将其转换成本地代码运行；内存管理系统负责对内存的管理和垃圾回收。

JVM的优点在于跨平台性、安全性和自动内存管理。跨平台性是指Java程序编译成字节码后可以在任何支持JVM的平台上运行；安全性是指Java程序在执行时受到JVM的保护，防止程序对系统造成破坏；自动内存管理则是指JVM会自动进行内存的分配和垃圾回收，程序员不需要手动管理内存。

在JVM的调优方面，可以通过调整JVM参数来优化程序的性能。例如，可以通过调整内存参数来提高程序的内存使用效率，也可以通过调整JIT编译器参数来优化代码执行效率。

总之，JVM是Java语言的核心组件，它的稳定性、性能和安全性对于Java程序的开发和运行都至关重要。

## JVM内存结构

> 百度，小米，阿里，华讯网络，美团，阿里，蚂蚁

**JDK 1.8 之前** ：

![Java 运行时数据区域（JDK1.8 之前）](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png)

**JDK 1.8 之后** ：

![Java 运行时数据区域（JDK1.8 之后）](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png)

Java虚拟机（JVM）的内存区域可以划分为以下几个部分：

1. 程序计数器：程序计数器是一块较小的内存区域，它可以看做是当前线程所执行的字节码的行号指示器。每个线程都有自己独立的程序计数器，它保证了线程切换后能够恢复到正确的执行位置。
2. 虚拟机栈：每个线程都有自己的虚拟机栈，用于存储方法执行的局部变量、操作数栈、方法出口等信息。每个方法在执行的时候都会创建一个栈帧，并将其压入虚拟机栈中。当方法执行完成后，栈帧会出栈并被垃圾回收器回收。
3. 本地方法栈：本地方法栈与虚拟机栈类似，但是它为本地方法（使用C语言或其他语言实现的方法）服务。与虚拟机栈一样，每个线程都有自己的本地方法栈。
4. 堆：Java堆是JVM中最大的内存区域，用于存储对象实例和数组。所有的对象实例和数组都需要在堆中分配内存，并在使用完毕后由垃圾回收器回收。Java堆可以分为新生代和老年代两部分，新生代又可以分为Eden空间、Survivor空间（From空间和To空间）。
5. 方法区：方法区用于存储类的信息、常量、静态变量、即时编译器编译后的代码等数据。在JDK8及以前，方法区是永久代（PermGen），在JDK8之后被移除，改为了元空间（Metaspace），元空间并不在虚拟机内存中，而是使用本地内存。
6. 运行时常量池：每个类都有自己的常量池，用于存储编译期间生成的各种字面量和符号引用。在运行期间，还可以将新的常量放入运行时常量池中，例如String类的intern()方法就会将字符串常量放入常量池中。

除了上述内存区域之外，还有一些其他的内存区域，例如直接内存、线程共享区等。直接内存是通过NIO库使用的一种特殊内存区域，它不受JVM堆内存大小的限制，但是它的分配和回收需要手动控制。线程共享区是一种用于存储线程共享数据的内存区域，例如线程池的任务队列就可以使用线程共享区实现。

## JVM外的内存

> 蚂蚁

在Java应用程序中，JVM内存是Java程序执行时使用的主要内存。除了JVM内存，还有许多其他类型的内存可供使用，包括本地内存和操作系统内存等。

本地内存是JVM外的内存，可以通过Java本地接口（Java Native Interface，JNI）访问。Java本地接口是一种允许Java程序调用本地（即非Java）代码的机制。本地内存通常由本地代码分配和释放，但可以通过JNI从Java代码中分配和释放。

操作系统内存也可以由Java程序使用。Java程序可以通过Java提供的API访问操作系统级别的内存分配器，并在其中分配内存。但是，这种内存通常不是直接从Java程序中分配的，而是通过与操作系统交互的本地代码分配的。

需要注意的是，使用本地内存和操作系统内存可以增加程序的复杂性和风险，因为它们不受JVM的管理和保护。因此，应该谨慎使用这些类型的内存，并确保正确地分配和释放它们，以避免内存泄漏和其他内存相关的问题。

## 虚拟机栈中栈帧的内部结构

> 美团

在JVM内存区域中，每个线程都会有自己的栈空间，每个方法在执行的时候都会创建一个栈帧，用于存储该方法执行过程中的局部变量、操作数栈、方法返回值和异常信息等。栈帧的内部结构包括以下几个部分：

1. 局部变量表：用于存储方法参数和局部变量的值，包括基本数据类型、对象引用和returnAddress类型。局部变量表的大小在编译期就已经确定，并且在方法调用时分配空间。
2. 操作数栈：用于存储方法执行过程中的操作数。当方法被调用时，参数传递通过局部变量表进行，而操作数则通过操作数栈进行。操作数栈的大小也是在编译期就已经确定的，同时在方法调用时分配空间。
3. 动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，用于支持方法调用时的动态链接。
4. 方法返回地址：当方法执行完成后，程序需要回到该方法被调用的地方继续执行。方法返回地址即为程序需要回到的地址。
5. 异常处理表：用于存储异常处理信息，包括异常处理代码在字节码中的位置、异常类型、处理代码在常量池中的位置等信息。

以上是栈帧的主要内部结构，栈帧还包括其他一些辅助信息，如局部变量表和操作数栈的最大深度、栈帧在虚拟机栈中的位置等。虚拟机会根据栈帧的信息进行方法的执行和异常处理。

## JVM堆的划分？

> 百度，华为

在Java虚拟机（JVM）中，堆是一块用于存储对象实例的内存区域，它是Java程序运行时所使用的内存区域之一。

堆内存可以被划分为三个部分：

1. 新生代（Young Generation）：新创建的对象都会被分配到新生代。它又分为 Eden空间、From Survivor空间和To Survivor空间。大部分对象在新生代被分配，只有在多次垃圾回收后仍然存活的对象才会被移动到老年代。
2. 老年代（Old Generation）：经过多次垃圾回收后仍然存活的对象会被移动到老年代。由于垃圾回收器对老年代的垃圾回收效率较低，所以老年代相对比较稳定，它的内存分配速度较慢。
3. 永久代（Perm Generation）：永久代是JVM用于存储类信息和常量池的区域。在JDK 8之后，永久代已经被元空间（Metaspace）所取代。

需要注意的是，堆内存的大小是可以通过JVM参数进行配置的。如果程序需要创建大量的对象实例，需要增加堆内存的大小，否则可能会出现OutOfMemoryError异常。

## 字节码如何加载到内存当中，存储在哪个区域，生成的 Class 对象存储在哪里

> 阿里云

字节码是由类加载器（ClassLoader）加载到内存中的，存储在方法区（Metaspace）中。当类加载器加载字节码时，会将字节码文件转换成一个个的 Class 对象，并将这些对象存储在方法区中。每个 Class 对象都对应着一个具体的类，包含了这个类的类名、访问修饰符、成员变量、方法等信息。Class 对象也是存储在方法区中的。在Java程序运行期间，如果需要使用反射机制，就需要通过 Class 对象来获取类的信息。由于字节码和 Class 对象都存储在方法区中，因此也被称为“永久代”。在Java 8及以后的版本中，永久代被移除，取而代之的是Metaspace，它不再是方法区的一部分，而是位于堆内存中的一个特殊区域。

## java内存泄露和排查

> 华为

Java内存泄露是指程序在运行过程中，由于某些原因而导致系统内存被浪费，从而影响程序的性能。要排查Java内存泄露，可以使用内存分析工具，如JProfiler、YourKit等，来检测程序中是否存在内存泄露问题。

- 检查程序中是否存在内存泄漏的代码，如未正确释放资源、未正确关闭流等。
- 检查程序中是否存在内存溢出的代码，如无限循环、无限递归等。
- 检查程序中是否存在内存抖动的代码，如频繁创建和销毁对象等。
- 检查程序中是否存在内存碎片的代码，如频繁分配和释放内存空间等。

## OOM出现的原因，出现了怎么办？

> 华为

1. 分配过少：JVM 初始化内存小，业务使用了大量内存；或者不同 JVM 区域分配内存不合理
2. 代码漏洞：某一个对象被频繁申请，不用了之后却没有被释放，导致内存耗尽
3. `jmap -heap` 查看是否内存分配过小
4. `jmap -histo` 查看是否有明显的对象分配过多且没有释放情况
5. `jmap -dump` 导出 JVM 当前内存快照，使用 JDK 自带或 MAT 等工具分析快照

## 服务OOM怎么办

> 美团

当服务出现OOM（Out Of Memory）时，可以采取以下措施来解决：

1.检查服务的内存使用情况，查看是否有内存泄漏；

2.检查服务的配置，确保服务的内存配置是否合理；

3.检查服务的程序代码，确保服务的程序代码是否有内存泄漏；

4.如果服务的内存使用量较高，可以考虑重启服务，以释放内存；

5.如果服务的内存使用量较高，可以考虑增加服务的内存配置，以提高服务的性能。

## 遇到的OOM场景

> 蚂蚁

1. 内存泄漏：内存泄漏是指程序中创建的对象没有被正确释放，导致其占用的内存无法被回收。内存泄漏可能会导致内存占用不断增加，最终导致OOM错误。解决内存泄漏问题的方法包括检查程序代码、使用内存分析工具等。
2. 大对象：大对象是指占用大量内存的对象，如大数组、大集合、大字符串等。如果程序中创建了过多的大对象，可能会导致内存不足，最终导致OOM错误。解决大对象问题的方法包括使用分页、懒加载、分批处理等方式，减少一次性加载大量数据的情况。
3. 频繁的Full GC：Full GC是指对整个堆进行垃圾回收。如果程序中频繁进行Full GC，可能会导致应用程序的响应时间变长，最终导致OOM错误。解决频繁Full GC问题的方法包括优化程序代码、增加内存大小、调整GC策略等。
4. 内存不足：如果程序中创建的对象占用内存超过了可用的内存大小，可能会导致OOM错误。解决内存不足问题的方法包括增加内存大小、调整内存分配策略等。

在Java应用程序中，可以通过监控堆内存、GC日志等方式，及时发现内存问题，并进行分析和解决。同时，也可以使用Java内存分析工具（如VisualVM、MAT、JProfiler等）来识别内存泄漏和大对象等问题。

## 对象创建流程

> 阿里，百度

当我们使用Java关键字 `new` 来创建一个对象时，具体的对象创建流程如下：

1. 检查该对象是否已经被类加载器加载，如果没有，则进行类加载。类加载时，会进行静态变量初始化和静态代码块的执行。
2. 为该对象分配内存空间。Java中的对象内存分配有两种方式：
   - 栈上分配：栈上分配对象时，对象实际上并不存储在栈中，只是栈上分配一段内存空间，用于存储该对象的引用。当该对象超出作用域后，该内存空间自动被回收。
   - 堆上分配：大多数情况下，Java对象是在堆中分配的，使用 `new` 关键字创建对象时，会在堆中分配一块连续的内存空间。
3. 初始化对象。在Java中，初始化对象分为两个阶段：成员变量的初始化和构造函数的执行。成员变量的初始化包括默认初始化和显式初始化。默认初始化是指Java在为对象分配内存空间后，自动将成员变量赋上一个默认值。显式初始化是指程序员在定义成员变量时，为其赋初值。构造函数的执行是在成员变量初始化后，按照代码顺序执行构造函数中的代码。
4. 返回对象引用。将对象的引用返回给程序员，程序员可以通过该引用对对象进行操作。

需要注意的是，对象创建流程中的第一步和第二步可能会被JVM进行优化，具体优化方式和时机取决于具体JVM实现。

## Java对象的生命周期

> 蚂蚁

Java对象的生命周期通常可以分为以下几个阶段：

1. 创建阶段（Instantiation）：在内存中分配对象所需的空间，并进行对象的初始化操作。当使用`new`关键字或反射机制创建一个新的对象时，就进入了创建阶段。
2. 使用阶段（In-Use）：对象被创建后，进入了使用阶段。在此阶段，可以调用对象的方法和访问其属性，直到对象不再被引用或被赋值为`null`，对象就会进入垃圾回收阶段。
3. 垃圾回收阶段（Garbage Collection）：在Java中，垃圾回收是由Java虚拟机自动完成的。当一个对象不再被引用或被赋值为`null`时，它就会被标记为垃圾对象。在垃圾回收器运行时，会对标记的垃圾对象进行清理，释放它们所占用的内存空间。Java的垃圾回收机制可以大大降低程序员的内存管理负担，提高程序的稳定性和安全性。
4. 终结阶段（Finalization）：Java提供了一个`finalize()`方法，该方法会在垃圾回收器清理对象之前被调用。该方法可以用于释放对象占用的其他资源或执行其他必要的清理操作。需要注意的是，`finalize()`方法只会被调用一次，且无法保证在何时执行。

Java对象的生命周期是由Java虚拟机控制的，程序员只需要关注对象的创建和使用，而无需手动释放内存。

------

# 垃圾回收

> 美团
>

## Full GC 触发机制

> 阿里云，百度

Full GC（Full Garbage Collection）是指对整个Java堆进行垃圾回收的操作。相比于部分区域的垃圾回收（如Young GC），Full GC的代价更高，因此一般情况下应尽量避免频繁触发。

Full GC的触发时机主要有以下几种情况：

1. 系统空间不足：当Java虚拟机中的堆空间快满时，可能会触发Full GC来回收垃圾，以腾出更多的空间。如果在Full GC之后还是无法满足需要的空间，则会抛出OutOfMemoryError异常。
2. 调用System.gc()方法：虽然调用System.gc()方法并不一定会导致Full GC的执行，但是它会增加Full GC执行的概率，因为这个方法会提示Java虚拟机执行垃圾回收。
3. 老年代空间不足：当老年代中的空间快满时，可能会触发Full GC，以回收不再使用的对象，以便为新的对象腾出空间。
4. 永久代空间不足：当永久代中的空间快满时，也可能会触发Full GC。永久代主要用于存储类的元数据信息，如类名、方法名等，如果存储了太多的类信息，就会导致永久代空间不足。

需要注意的是，Full GC的触发时机可能因不同的Java虚拟机实现而有所不同，也可能因为虚拟机的一些参数配置而有所差异。在实际应用中，应根据具体情况进行调整和优化，以避免频繁触发Full GC。

## Full GC 排查

> 蚂蚁

Full GC（Full Garbage Collection）通常是由于老年代空间不足或者永久代空间不足触发的。Full GC 会导致应用程序暂停，对性能有很大影响，因此需要及时排查和解决 Full GC 问题。

排查 Full GC 问题的一般步骤如下：

1. 查看 GC 日志，确定 Full GC 触发的原因，例如老年代或永久代空间不足。
2. 分析应用程序代码，确定是否存在内存泄漏或内存使用过度的情况。
3. 调整 JVM 内存参数，增加老年代或永久代的大小，以避免 Full GC 的触发。
4. 优化代码，减少内存使用，例如使用对象池、缓存等技术。
5. 调整 GC 策略，例如增加并行 GC 线程数、使用 CMS GC 等。
6. 如果以上措施无法解决问题，可能需要升级 JVM 版本或更换硬件。

在实际的排查中，可以结合使用一些工具，如 jstat、jmap、jconsole 等来协助排查 Full GC 问题。例如可以使用 jstat 命令监控老年代和永久代的使用情况，使用 jmap 命令生成堆转储文件并分析内存使用情况，使用 jconsole 可以实时查看 JVM 的内存使用情况等。

## Full GC 和 Minor GC

> 蚂蚁

Minor GC：也被称为年轻代GC，只会清理年轻代的内存空间。年轻代通常分为 Eden 区和两个 Survivor 区，新生的对象首先被分配到 Eden 区，当 Eden 区满时，会触发 Minor GC，将 Eden 区和 Survivor 区中所有存活的对象复制到另一个 Survivor 区，同时清空 Eden 区和上一个 Survivor 区。多次复制后，Survivor 区中存活的对象会被复制到老年代。

Full GC：也被称为老年代GC，会清理整个堆内存中的对象，包括年轻代和老年代。Full GC的工作流程如下：

1. 首先，虚拟机会暂停应用程序的所有线程。
2. 然后，虚拟机会扫描堆内存中的所有对象，并标记所有存活的对象。
3. 接下来，虚拟机会回收所有没有被标记的对象。
4. 最后，虚拟机会将存活的对象压缩到堆的一端。

Full GC通常是由以下原因触发的：

1. 永久代（Metaspace）空间满了。
2. 某个代内存空间耗尽，需要扩容。
3. 显式地调用了System.gc()。

## jvm的Gc分代算法是怎么样的？

> 哈啰

JVM 中的 GC（Garbage Collection）分代算法是基于分代假说提出的，即大部分对象的生命周期很短，只有少部分对象会存活较长时间。因此，GC 将堆内存分为不同的代，分别采用不同的 GC 策略进行垃圾回收，以达到更高的回收效率。

JVM 的分代模型通常分为年轻代（Young Generation）、老年代（Old Generation）和永久代（Permanent Generation）三个部分，其中永久代在 JDK 8 中已经被移除，被元数据区（Metaspace）所取代。

年轻代通常分为 Eden 区和两个 Survivor 区，新生的对象首先被分配到 Eden 区，当 Eden 区满时，会触发 Minor GC，将 Eden 区和 Survivor 区中所有存活的对象复制到另一个 Survivor 区，同时清空 Eden 区和上一个 Survivor 区。多次复制后，Survivor 区中存活的对象会被复制到老年代，当老年代满时会触发 Full GC。

老年代中存活的对象通常较多，而且生命周期较长，因此老年代的垃圾回收需要更谨慎。常见的垃圾回收策略有标记-清除算法和标记-整理算法。标记-清除算法会将存活的对象标记出来，然后将不可达对象清除掉。标记-整理算法则会将存活的对象移到一端，然后清理掉边界之外的所有对象。

在实际应用中，JVM 的 GC 策略还会受到多种因素的影响，如堆内存大小、应用负载、垃圾回收器的选择等。因此，我们需要了解 GC 的基本原理，并根据具体情况进行调优，以提高应用的性能和稳定性。

## 老年代的对象引用了年轻代的对象会怎样？

> 哈啰

当老年代的对象引用了年轻代的对象时，这些年轻代对象将无法被回收，因为老年代对象的生命周期比年轻代对象的生命周期更长。这种情况被称为“跨代引用”，会导致年轻代对象的内存占用量增加，可能会影响JVM的性能和内存使用效率。

为避免跨代引用，通常会采用两种方法：

1. 限制老年代对象对年轻代对象的引用，例如使用WeakReference、SoftReference等类型的引用来管理对象，使得当老年代对象不再引用这些年轻代对象时，这些年轻代对象能够被垃圾回收。
2. 将年轻代和老年代分别使用不同的内存空间，使得年轻代和老年代之间不存在引用关系，从而避免跨代引用的问题。这是G1等新一代垃圾回收器的优化策略之一。

## JVM新生代怎么划分，大对象怎么分配

> 字节

JVM的新生代主要是用来存储新创建的对象，通常情况下新生代被划分为两个部分：一个是Eden空间，另外一个是两个大小相等的Survivor空间（一般为S0和S1）。

当一个新的对象被创建时，它会首先被分配到Eden空间中。如果Eden空间没有足够的空间来存储对象，JVM会触发一次Minor GC，这时会对Eden空间和Survivor空间进行垃圾回收。在垃圾回收过程中，所有可以被回收的对象都会被回收，而所有还存活的对象会被移动到Survivor空间中。在下一次Minor GC时，同样会对Eden空间和Survivor空间进行垃圾回收，但是此时从上一次GC开始存活下来的对象会被移动到另一个Survivor空间中。这个过程会一直进行下去，直到一个Survivor空间被填满，此时还存活的对象就会被移动到另一个Survivor空间中。

当一个对象的大小超过了Eden空间的大小时，它就会被认为是一个大对象。由于大对象无法在Eden空间中分配，因此它们通常会被直接分配到老年代中。为了避免大对象在新生代中分配造成内存浪费，JVM提供了一个参数，可以通过设置该参数来限制大对象在新生代中的分配。如果一个对象的大小超过了该参数设置的阈值，那么它就会被直接分配到老年代中。该参数的名称是`-XX:PretenureSizeThreshold`，可以通过设置该参数来限制大对象在新生代中的分配。例如，可以将该参数设置为1024，表示只有当一个对象的大小超过1024字节时，才会被直接分配到老年代中。

## 说说 JVM 里对象的内存分配和回收是怎么进行的

> 阿里云

Java 虚拟机 (JVM) 中的对象内存分配和回收是由垃圾收集器 (Garbage Collector) 负责的。垃圾收集器跟踪对象的生命周期并在其不再被引用时进行回收。下面是 JVM 中对象内存分配和回收的基本过程：

1. 对象的内存分配

当 JVM 创建一个新的对象时，它会在堆内存中分配一块连续的空间以存储该对象的数据。对象的大小可以通过 `new` 关键字或者 JVM 内部的其他方式动态计算得出。

在分配内存时，JVM 需要考虑各种因素，例如对象的大小、JVM 堆的剩余空间、分配策略等等。通常情况下，对象会被分配在新生代的 Eden 区域中。

2. 对象的回收

当对象不再被引用时，垃圾收集器就会对其进行回收。JVM 的垃圾收集器会定期扫描堆内存，标记那些还在使用中的对象，并回收那些没有被引用的对象。

JVM 中的垃圾收集器采用不同的算法和策略来回收对象，例如标记-清除算法、复制算法、标记-整理算法等等。不同的算法和策略适用于不同的场景，可以根据应用程序的需求进行选择和配置。

## 如何确保对象可以被回收？

> 哈啰

在 Java 中，可以使用垃圾回收器来回收不再使用的对象。垃圾回收器在回收对象时，需要满足两个条件：

1. 对象不再被引用
2. 对象没有被强制持有

在应用中，我们可以通过以下方式来确保对象可以被回收：

1. 将引用置为 null：当一个对象不再被使用时，我们可以将其引用置为 null。这样，当垃圾回收器扫描到该对象时，会判断其没有被引用，从而将其回收。
2. 尽早释放资源：在使用对象时，如果需要占用大量资源（如文件、网络连接等），我们需要尽早释放这些资源。一旦这些资源得到释放，对应的对象就没有被强制持有，垃圾回收器就可以回收这些对象。
3. 避免循环引用：如果存在循环引用的情况，即两个或多个对象相互引用，但没有任何一个对象可以被直接访问，垃圾回收器就无法回收这些对象。为了避免循环引用，可以使用弱引用、软引用或虚引用等方式来管理对象。
4. 使用 finalize() 方法：在某些情况下，我们可能需要在对象被回收之前，执行一些清理工作。可以通过实现 finalize() 方法来达到这个目的。当垃圾回收器准备回收一个对象时，会先调用对象的 finalize() 方法，然后再回收对象。但是，使用 finalize() 方法来确保对象被回收并不可靠，因为 finalize() 方法的调用时机不确定，而且会影响垃圾回收的性能。

总之，要确保对象可以被回收，我们需要在代码编写和资源管理方面做出相应的努力，以减少内存泄漏和循环引用等问题的出现。

## 判断对象是否可回收（垃圾）

> 小米，蚂蚁，华为，阿里

### 1. 引用计数算法

它将每个对象的引用计数器初始化为 0。每当一个对象被引用时，它的引用计数器加 1，当它所引用的对象被销毁时，它的引用计数器减 1。当对象的引用计数器为 0 时，说明对象不再被引用，可以被回收。

两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。

### 2. 可达性分析算法

> 美团

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

**哪些对象可以作为 GC Roots 呢？**

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

**对象可以被回收，就代表一定会被回收吗？**

即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

------

## gc中的引用计数法有哪些缺陷

> 小米

- 它需要单独的字段存储计数器,这样的做法增加了`存储空间的开销`。

- 每次复制都需要更新计数器,伴随着加法和减法操作,这增加了`时间开销`。

- 引用计数器有一个严重的问题,即`无法处理循环引用`的情况。这是一条致命缺陷,导致在Java的垃圾回收器中没有使用这类算法。

## Java 的引用有哪些类型？

> 百度，快手，美团

1. 强引用：在Java中最为常见的引用类型，如果一个对象具有强引用，垃圾回收器不会回收这个对象。例如，Object obj = new Object()，obj就是一个强引用，只有当obj赋值为null或者超出了其作用域，才会被垃圾回收器回收。
2. 软引用：如果一个对象具有软引用，那么垃圾回收器会在内存不足时将其回收。在Java中，可以通过SoftReference类来创建软引用。通常用于实现缓存的功能，比如内存敏感的高速缓存。
3. 弱引用：如果一个对象具有弱引用，那么垃圾回收器会在下一次垃圾回收时将其回收，无论内存是否足够。在Java中，可以通过WeakReference类来创建弱引用。常用于实现一些特殊的功能，如ThreadLocal。
4. 虚引用：也被称为幽灵引用或者幻影引用，是Java中最弱的引用类型。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。在Java中，可以通过PhantomReference类来创建虚引用。通常用于跟踪对象被垃圾回收的状态，例如在对象被回收之前做一些清理工作。

------

## 有哪些垃圾回收GC算法？

> 百度，英雄游戏，小米，腾讯，阿里，美团基础平台，蚂蚁，华为

### 1. 标记 - 清除

![image](https://pdai.tech/images/pics/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg)

标记-清除算法通过先标记所有存活对象，再清除所有未被标记的垃圾对象。这种算法虽然简单，但会产生内存碎片，影响堆内存的利用效率。

### 2. 标记 - 整理

![image](https://pdai.tech/images/pics/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg)

标记-整理算法则是将存活的对象向一端移动，然后清空端边界以外的空间。这种算法可以避免内存碎片，但需要进行两次扫描，效率较低。

### 3. 复制

![image](https://pdai.tech/images/pics/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg)

复制算法则是将内存分为两个相等的区域，每次只使用其中的一个。当这个区域满了之后，将其中的存活对象复制到另一个区域中，然后清空原来的区域。这种算法可以有效地避免内存碎片的产生，但需要耗费额外的空间。

### 4. 分代收集

分代收集算法则是根据对象的年龄将它们分为新生代和老年代两个部分，分别采用不同的垃圾回收算法。新生代通常使用复制算法，而老年代通常使用标记-整理算法。

## 可作为Gc roots的对象有哪些

> 百度，小米

1.虚拟机栈（栈帧中的本地变量表）中引用的对象；

2.方法区中的类静态属性引用的对象；

3.方法区中常量引用的对象；

4.本地方法栈中JNI（即一般说的Native方法）中引用的对象

## 你知道哪些垃圾收集器？

> 字节，百度，美团

### Serial 收集器

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![ Serial 收集器 ](https://javaguide.cn/assets/46873026.3a9311ec.png)

虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。

但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。

### ParNew 收集器

ParNew是一个用于新生代的垃圾收集器，使用了年轻代的复制算法。它和CMS一样，属于低停顿垃圾收集器，但是没有CMS那么复杂。ParNew主要用于多核CPU环境下的垃圾收集，使用多线程进行垃圾回收，能够更高效地利用CPU。在垃圾回收过程中，它采用了标记-复制算法，即将所有存活的对象复制到一块新的内存区域中，从而避免了碎片问题。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![ParNew 收集器 ](https://javaguide.cn/assets/22018368.df835851.png)

它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。

### Parallel Scavenge 收集器

Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 **那么它有什么特别之处呢？**

**Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![Parallel Scavenge 收集器 ](https://javaguide.cn/assets/22018368.df835851.png)

### Serial Old 收集器

**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

### Parallel Old 收集器

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

### CMS 收集器

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；（STW）
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短（STW）
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![CMS 垃圾收集器 ](https://javaguide.cn/assets/CMS%E6%94%B6%E9%9B%86%E5%99%A8.8a4d0487.png)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

### G1 收集器

> 阿里云

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

虽然 G1 也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。以前的收集器分代是划分新生代、老年代、持久代等。

G1 把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略去处理。

![G1 Heap Regions](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-35.png)

这样就避免了收集整个堆，而是按照若干个 Region 集进行收集，同时维护一个优先级列表，跟踪各个 Region 回收的“价值，优先收集价值高的 Region。

被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**（initial mark），标记了从 GC Root 开始直接关联可达的对象。STW（Stop the World）执行。
- **并发标记**（concurrent marking），和用户线程并发执行，从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、
- **最终标记**（Remark），是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录。
- **筛选回收**（Live Data Counting And Evacuation），首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，回收没有存活对象的Region并加入可用Region队列。

## G1和CMS的区别

> 阿里云

### 区别一： 使用范围不一样

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用
G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用

### 区别二： STW的时间

CMS收集器以最小的停顿时间为目标的收集器。

G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

### 区别三： 垃圾碎片

CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片

G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

### 区别四： 垃圾回收的过程不一样

CMS：初始标记、并发标记、重新标记、并发清除

G1：初始标记、并发标记、最终标记、筛选回收

------

## 你知道哪些内存分配与回收策略？（什么样的对象会进入老年代）

> 百度

**对象优先在 Eden 区分配**

大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC。

**大对象直接进入老年代**

大对象指需要大量连续内存空间的对象，典型是很长的字符串或数量庞大的数组。大对象容易导致内存还有不少空间就提前触发垃圾收集以获得足够的连续空间。

HotSpot 提供了 `-XX:PretenureSizeThreshold` 参数，大于该值的对象直接在老年代分配，避免在 Eden 和 Survivor 间来回复制。

**长期存活对象进入老年代**

虚拟机给每个对象定义了一个对象年龄计数器，存储在对象头。如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1。对象在 Survivor 中每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。对象晋升老年代的阈值可通过 `-XX:MaxTenuringThreshold` 设置。

**动态对象年龄判定**

为了适应不同内存状况，虚拟机不要求对象年龄达到阈值才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代。

**空间分配担保**

MinorGC 前虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。

如果不满足，虚拟机会查看 `-XX:HandlePromotionFailure` 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将冒险尝试一次 Minor GC，否则改成一次 FullGC。

冒险是因为新生代使用复制算法，为了内存利用率只使用一个 Survivor，大量对象在 Minor GC 后仍然存活时，需要老年代进行分配担保，接收 Survivor 无法容纳的对象。

------

# 类加载机制

------

## 类加载的过程是什么？

> zoom，美团，百度，阿里云，华为，京东，蚂蚁

1. 加载（Loading）：通过类的全限定名获取类的二进制字节流，并且将字节流转换成Java虚拟机可以使用的Java.lang.Class对象。

2. 链接（Linking）：分为以下3个步骤：

   a. 验证（Verification）：确保类的字节流符合Java虚拟机规范，并且不会危害虚拟机的安全。

   b. 准备（Preparation）：为类的静态变量分配内存空间，并且设置默认的初始值。

   c. 解析（Resolution）：将常量池中的符号引用转换成直接引用。

3. 初始化（Initialization）：初始化阶段是执行初始化方法 `<clinit> ()`方法，为类的静态变量赋值，执行静态代码块。

其中，类的加载是由Java虚拟机自动完成的。类的链接和初始化在类加载过程中按照需求自动完成，如果有必要也可以手动控制。

------

## 有哪些类加载器？

> 阿里云，邮储苏州研发

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由 C++实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。
3. **AppClassLoader(应用程序类加载器)** ：负责加载应用程序类路径上指定的类，包括用户自定义类和第三方类库。

------

## 什么是双亲委派机制？

> zoom，阿里，蚂蚁，京东

![双亲委派模型](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-46.png)

双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

## 双亲委派机制的优点，为什么要用双亲委派机制？

> 美团

1. 避免重复加载类：当一个类被加载时，双亲委派机制会先从父类加载器中查找是否已经加载该类，如果已经加载则直接返回已有的类，避免了重复加载类的问题，节省了内存空间和系统资源。
2. 加载安全可靠：双亲委派机制保证了类的加载安全可靠，因为它能够保证核心类库的安全性，防止非法代码替换Java的核心API。
3. 灵活可扩展：双亲委派机制使得Java类库的组织结构更加灵活可扩展。通过定义不同的类加载器，可以在应用程序中使用自定义的类或第三方库，而不会与Java核心API发生冲突。

## 哪些框架或者中间件对双亲委派模型造成了破坏

> 美团

虽然双亲委派模型可以在很大程度上保证Java应用程序的安全性，但仍有可能被破坏。一些框架或中间件，如OSGi、Jboss、Tomcat等，可能会打破双亲委派模型。这些框架和中间件通常使用自定义的类加载器，例如OSGi的BundleClassLoader和Tomcat的WebAppClassLoader，来加载特定的类或资源，绕过了双亲委派模型的限制。

此外，一些Java反射技术也可能会绕过双亲委派模型的限制。例如，可以使用反射API直接调用ClassLoader的defineClass方法来定义一个新的类，从而绕过类加载器的限制。

## 如何破坏双亲委派机制？

> zoom，阿里，蚂蚁

1. 自定义ClassLoader：可以通过自定义ClassLoader来实现破坏双亲委派机制。通过重写findClass()方法，可以在加载类时跳过父类加载器，直接加载子类加载器的类。
2. 线程上下文类加载器（Thread Context ClassLoader）：可以通过设置线程上下文类加载器来实现破坏双亲委派机制。当Java虚拟机需要加载类时，会优先使用线程上下文类加载器来加载类，如果线程上下文类加载器无法加载类，则会委托给父类加载器。
3. 使用SPI机制：可以使用Java提供的SPI（Service Provider Interface）机制来破坏双亲委派机制。在SPI机制中，通过在META-INF/services目录下的配置文件中指定接口的实现类，可以在运行时动态加载类。

## 一般什么场景要打破双亲委派

> 阿里

1. 系统类库升级：如果系统类库升级，而应用程序中的代码依赖于旧版本的类库，此时就需要打破双亲委派机制，以确保应用程序使用的是旧版本的类库。
2. 动态代理：动态代理需要在运行时动态生成类，如果使用双亲委派机制加载这些类，可能会出现类冲突问题，因此需要打破双亲委派机制。
3. OSGi：OSGi是一种基于模块化的动态架构，它需要在运行时动态加载模块和类，因此需要打破双亲委派机制。

## 双亲委派模型的好处

> 阿里

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

## ASM 是什么

> 阿里云

ASM（全称：Java字节码操纵框架）是一个轻量级的Java字节码操作框架，可以用于直接在内存中动态生成或者修改字节码。ASM提供了一个抽象的、底层的API，使得开发人员可以在编写类的字节码时借助框架的帮助，简化了字节码操作的复杂度，方便了动态生成类、修改类的字节码的操作。ASM是一个非常流行的Java字节码操作框架，它被广泛应用于许多开源项目和商业项目中，例如Hibernate、Spring、Tomcat等。

------

# 调优

## 线上服务CPU占用过高怎么排查？

> 阿里

1.先通过top命令找到消耗cpu很高的进程id。

2.根据进程找到消耗cpu很高的线程id。

3.对当前进程做stack,输出所有的堆栈信息。

解读：jstack 查看当前进程下的全部线程信息，jstack 加上线程ID

4.将第3步得到的线程ID转成16进制

5.根据的到的16进制ID找到堆栈的具体信息。

6.解读堆栈信息，定问题以及代码位置。

## JVM常见的调优参数？

> 百度

以下是JVM常见的调优参数：

1. -Xmx：用于设置JVM最大可用内存大小。例如，-Xmx4g表示最大可用内存为4GB。
2. -Xms：用于设置JVM初始分配的内存大小。例如，-Xms2g表示初始分配2GB内存。
3. -XX:MaxPermSize：用于设置永久代最大可用内存大小。默认值是64MB，但在使用大量类或字符串的应用程序中，需要增加此值。
4. -XX:+UseConcMarkSweepGC：用于启用CMS垃圾回收器，以在不中断应用程序的情况下执行垃圾收集。
5. -XX:+UseParallelGC：用于启用并行垃圾回收器，以提高垃圾收集效率。
6. -XX:NewSize：用于设置年轻代的初始大小。
7. -XX:MaxNewSize：用于设置年轻代的最大大小。
8. -XX:SurvivorRatio：用于设置年轻代中Eden空间和Survivor空间的大小比例。默认值为8。
9. -XX:+DisableExplicitGC：用于禁用显式的GC操作，以防止应用程序在不必要的情况下执行GC操作。
10. -XX:+UseG1GC：用于启用G1垃圾回收器，它是一种高效的分代垃圾回收器，适用于大型堆。

## JIT(just-in-time compiler)

> 美团

JIT编译器是一种在运行时将字节码编译为本地机器代码的编译器。在Java虚拟机（JVM）中，Java代码被编译成字节码，而不是直接编译为本地机器代码。JIT编译器负责将这些字节码转换为本地机器代码，并将其保存在缓存中以供重复使用。JIT编译器的优点是它可以根据运行时的情况来进行优化，从而提高代码的性能。

JIT编译器通常会在代码第一次执行时编译字节码。它会跟踪代码的执行情况，并根据情况进行优化，比如消除不必要的内存访问和减少方法调用开销等。这使得JIT编译器能够提高Java应用程序的性能，尤其是对于需要频繁执行的代码，比如循环和方法调用。

尽管JIT编译器有很多优点，但是在编译过程中也会增加一些开销。因此，对于一些仅仅执行一次或者很少执行的代码，JIT编译器可能会降低应用程序的性能。为了避免这种情况，JIT编译器通常会有一些预热机制，它们会在应用程序启动时就开始编译一些最常用的代码，从而避免了在运行时进行编译的开销。